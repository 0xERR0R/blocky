// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package model

import (
	"fmt"
	"strings"
)

const (
	// RequestProtocolTCP is a RequestProtocol of type TCP.
	// is the TCP protocol
	RequestProtocolTCP RequestProtocol = iota
	// RequestProtocolUDP is a RequestProtocol of type UDP.
	// is the UDP protocol
	RequestProtocolUDP
)

var ErrInvalidRequestProtocol = fmt.Errorf("not a valid RequestProtocol, try [%s]", strings.Join(_RequestProtocolNames, ", "))

const _RequestProtocolName = "TCPUDP"

var _RequestProtocolNames = []string{
	_RequestProtocolName[0:3],
	_RequestProtocolName[3:6],
}

// RequestProtocolNames returns a list of possible string values of RequestProtocol.
func RequestProtocolNames() []string {
	tmp := make([]string, len(_RequestProtocolNames))
	copy(tmp, _RequestProtocolNames)
	return tmp
}

var _RequestProtocolMap = map[RequestProtocol]string{
	RequestProtocolTCP: _RequestProtocolName[0:3],
	RequestProtocolUDP: _RequestProtocolName[3:6],
}

// String implements the Stringer interface.
func (x RequestProtocol) String() string {
	if str, ok := _RequestProtocolMap[x]; ok {
		return str
	}
	return fmt.Sprintf("RequestProtocol(%d)", x)
}

var _RequestProtocolValue = map[string]RequestProtocol{
	_RequestProtocolName[0:3]: RequestProtocolTCP,
	_RequestProtocolName[3:6]: RequestProtocolUDP,
}

// ParseRequestProtocol attempts to convert a string to a RequestProtocol.
func ParseRequestProtocol(name string) (RequestProtocol, error) {
	if x, ok := _RequestProtocolValue[name]; ok {
		return x, nil
	}
	return RequestProtocol(0), fmt.Errorf("%s is %w", name, ErrInvalidRequestProtocol)
}

// MarshalText implements the text marshaller method.
func (x RequestProtocol) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *RequestProtocol) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseRequestProtocol(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ResponseTypeRESOLVED is a ResponseType of type RESOLVED.
	// the response was resolved by the external upstream resolver
	ResponseTypeRESOLVED ResponseType = iota
	// ResponseTypeCACHED is a ResponseType of type CACHED.
	// the response was resolved from cache
	ResponseTypeCACHED
	// ResponseTypeBLOCKED is a ResponseType of type BLOCKED.
	// the query was blocked
	ResponseTypeBLOCKED
	// ResponseTypeCONDITIONAL is a ResponseType of type CONDITIONAL.
	// the query was resolved by the conditional upstream resolver
	ResponseTypeCONDITIONAL
	// ResponseTypeCUSTOMDNS is a ResponseType of type CUSTOMDNS.
	// the query was resolved by a custom rule
	ResponseTypeCUSTOMDNS
	// ResponseTypeHOSTSFILE is a ResponseType of type HOSTSFILE.
	// the query was resolved by looking up the hosts file
	ResponseTypeHOSTSFILE
	// ResponseTypeFILTERED is a ResponseType of type FILTERED.
	// the query was filtered by query type
	ResponseTypeFILTERED
	// ResponseTypeNOTFQDN is a ResponseType of type NOTFQDN.
	// the query was filtered as it is not fqdn conform
	ResponseTypeNOTFQDN
	// ResponseTypeSPECIAL is a ResponseType of type SPECIAL.
	// the query was resolved by the special use domain name resolver
	ResponseTypeSPECIAL
)

var ErrInvalidResponseType = fmt.Errorf("not a valid ResponseType, try [%s]", strings.Join(_ResponseTypeNames, ", "))

const _ResponseTypeName = "RESOLVEDCACHEDBLOCKEDCONDITIONALCUSTOMDNSHOSTSFILEFILTEREDNOTFQDNSPECIAL"

var _ResponseTypeNames = []string{
	_ResponseTypeName[0:8],
	_ResponseTypeName[8:14],
	_ResponseTypeName[14:21],
	_ResponseTypeName[21:32],
	_ResponseTypeName[32:41],
	_ResponseTypeName[41:50],
	_ResponseTypeName[50:58],
	_ResponseTypeName[58:65],
	_ResponseTypeName[65:72],
}

// ResponseTypeNames returns a list of possible string values of ResponseType.
func ResponseTypeNames() []string {
	tmp := make([]string, len(_ResponseTypeNames))
	copy(tmp, _ResponseTypeNames)
	return tmp
}

var _ResponseTypeMap = map[ResponseType]string{
	ResponseTypeRESOLVED:    _ResponseTypeName[0:8],
	ResponseTypeCACHED:      _ResponseTypeName[8:14],
	ResponseTypeBLOCKED:     _ResponseTypeName[14:21],
	ResponseTypeCONDITIONAL: _ResponseTypeName[21:32],
	ResponseTypeCUSTOMDNS:   _ResponseTypeName[32:41],
	ResponseTypeHOSTSFILE:   _ResponseTypeName[41:50],
	ResponseTypeFILTERED:    _ResponseTypeName[50:58],
	ResponseTypeNOTFQDN:     _ResponseTypeName[58:65],
	ResponseTypeSPECIAL:     _ResponseTypeName[65:72],
}

// String implements the Stringer interface.
func (x ResponseType) String() string {
	if str, ok := _ResponseTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ResponseType(%d)", x)
}

var _ResponseTypeValue = map[string]ResponseType{
	_ResponseTypeName[0:8]:   ResponseTypeRESOLVED,
	_ResponseTypeName[8:14]:  ResponseTypeCACHED,
	_ResponseTypeName[14:21]: ResponseTypeBLOCKED,
	_ResponseTypeName[21:32]: ResponseTypeCONDITIONAL,
	_ResponseTypeName[32:41]: ResponseTypeCUSTOMDNS,
	_ResponseTypeName[41:50]: ResponseTypeHOSTSFILE,
	_ResponseTypeName[50:58]: ResponseTypeFILTERED,
	_ResponseTypeName[58:65]: ResponseTypeNOTFQDN,
	_ResponseTypeName[65:72]: ResponseTypeSPECIAL,
}

// ParseResponseType attempts to convert a string to a ResponseType.
func ParseResponseType(name string) (ResponseType, error) {
	if x, ok := _ResponseTypeValue[name]; ok {
		return x, nil
	}
	return ResponseType(0), fmt.Errorf("%s is %w", name, ErrInvalidResponseType)
}

// MarshalText implements the text marshaller method.
func (x ResponseType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ResponseType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseResponseType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
