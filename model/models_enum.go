// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package model

import (
	"fmt"
	"strings"
)

const (
	// RequestProtocolTCP is a RequestProtocol of type TCP.
	// is the TPC protocol
	RequestProtocolTCP RequestProtocol = iota
	// RequestProtocolUDP is a RequestProtocol of type UDP.
	// is the UDP protocol
	RequestProtocolUDP
)

const _RequestProtocolName = "TCPUDP"

var _RequestProtocolNames = []string{
	_RequestProtocolName[0:3],
	_RequestProtocolName[3:6],
}

// RequestProtocolNames returns a list of possible string values of RequestProtocol.
func RequestProtocolNames() []string {
	tmp := make([]string, len(_RequestProtocolNames))
	copy(tmp, _RequestProtocolNames)
	return tmp
}

var _RequestProtocolMap = map[RequestProtocol]string{
	0: _RequestProtocolName[0:3],
	1: _RequestProtocolName[3:6],
}

// String implements the Stringer interface.
func (x RequestProtocol) String() string {
	if str, ok := _RequestProtocolMap[x]; ok {
		return str
	}
	return fmt.Sprintf("RequestProtocol(%d)", x)
}

var _RequestProtocolValue = map[string]RequestProtocol{
	_RequestProtocolName[0:3]: 0,
	_RequestProtocolName[3:6]: 1,
}

// ParseRequestProtocol attempts to convert a string to a RequestProtocol
func ParseRequestProtocol(name string) (RequestProtocol, error) {
	if x, ok := _RequestProtocolValue[name]; ok {
		return x, nil
	}
	return RequestProtocol(0), fmt.Errorf("%s is not a valid RequestProtocol, try [%s]", name, strings.Join(_RequestProtocolNames, ", "))
}

// MarshalText implements the text marshaller method
func (x RequestProtocol) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *RequestProtocol) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseRequestProtocol(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ResponseTypeRESOLVED is a ResponseType of type RESOLVED.
	// the response was resolved by the external upstream resolver
	ResponseTypeRESOLVED ResponseType = iota
	// ResponseTypeCACHED is a ResponseType of type CACHED.
	// the response was resolved from cache
	ResponseTypeCACHED
	// ResponseTypeBLOCKED is a ResponseType of type BLOCKED.
	// the query was blocked
	ResponseTypeBLOCKED
	// ResponseTypeCONDITIONAL is a ResponseType of type CONDITIONAL.
	// the query was resolved by the conditional upstream resolver
	ResponseTypeCONDITIONAL
	// ResponseTypeCUSTOMDNS is a ResponseType of type CUSTOMDNS.
	// the query was resolved by a custom rule
	ResponseTypeCUSTOMDNS
)

const _ResponseTypeName = "RESOLVEDCACHEDBLOCKEDCONDITIONALCUSTOMDNS"

var _ResponseTypeNames = []string{
	_ResponseTypeName[0:8],
	_ResponseTypeName[8:14],
	_ResponseTypeName[14:21],
	_ResponseTypeName[21:32],
	_ResponseTypeName[32:41],
}

// ResponseTypeNames returns a list of possible string values of ResponseType.
func ResponseTypeNames() []string {
	tmp := make([]string, len(_ResponseTypeNames))
	copy(tmp, _ResponseTypeNames)
	return tmp
}

var _ResponseTypeMap = map[ResponseType]string{
	0: _ResponseTypeName[0:8],
	1: _ResponseTypeName[8:14],
	2: _ResponseTypeName[14:21],
	3: _ResponseTypeName[21:32],
	4: _ResponseTypeName[32:41],
}

// String implements the Stringer interface.
func (x ResponseType) String() string {
	if str, ok := _ResponseTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ResponseType(%d)", x)
}

var _ResponseTypeValue = map[string]ResponseType{
	_ResponseTypeName[0:8]:   0,
	_ResponseTypeName[8:14]:  1,
	_ResponseTypeName[14:21]: 2,
	_ResponseTypeName[21:32]: 3,
	_ResponseTypeName[32:41]: 4,
}

// ParseResponseType attempts to convert a string to a ResponseType
func ParseResponseType(name string) (ResponseType, error) {
	if x, ok := _ResponseTypeValue[name]; ok {
		return x, nil
	}
	return ResponseType(0), fmt.Errorf("%s is not a valid ResponseType, try [%s]", name, strings.Join(_ResponseTypeNames, ", "))
}

// MarshalText implements the text marshaller method
func (x ResponseType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ResponseType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseResponseType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
