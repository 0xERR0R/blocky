{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Blocky","text":"<p>Blocky is a DNS proxy and ad-blocker for the local network written in Go with following features:</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Blocking -  Blocking of DNS queries with external lists (Ad-block, malware) and allowlisting</p> <ul> <li>Definition of allow/denylists per client group (Kids, Smart home devices, etc.)</li> <li>Periodical reload of external allow/denylists</li> <li>Regex support</li> <li>Blocking of request domain, response CNAME (deep CNAME inspection) and response IP addresses (against IP lists)</li> </ul> </li> <li> <p>Advanced DNS configuration -  not just an ad-blocker</p> <ul> <li>Custom DNS resolution for certain domain names</li> <li>Conditional forwarding to external DNS server</li> <li>Upstream resolvers can be defined per client group</li> </ul> </li> <li> <p>Performance -  Improves speed and performance in your network</p> <ul> <li>Customizable caching of DNS answers for queries -&gt; improves DNS resolution speed and reduces amount of external DNS   queries</li> <li>Prefetching and caching of often used queries</li> <li>Using multiple external resolver simultaneously</li> <li>Low memory footprint</li> </ul> </li> <li> <p>Various Protocols -  Supports modern DNS protocols</p> <ul> <li>DNS over UDP and TCP</li> <li>DNS over HTTPS (aka DoH)</li> <li>DNS over TLS (aka DoT)</li> </ul> </li> <li> <p>Security and Privacy -  Secure communication</p> <ul> <li>Supports modern DNS extensions: DNSSEC, eDNS, ...</li> <li>DNSSEC validation of upstream resolvers</li> <li>Free configurable blocking lists - no hidden filtering etc.</li> <li>Provides DoH Endpoint</li> <li>Uses random upstream resolvers from the configuration - increases your privacy through the distribution of your DNS   traffic over multiple provider</li> <li>Open source development</li> <li>Blocky does NOT collect any user data, telemetry, statistics etc.</li> </ul> </li> <li> <p>Integration -  various integration</p> <ul> <li>Prometheus metrics</li> <li>Prepared Grafana dashboards (Prometheus and database)</li> <li>Logging of DNS queries per day / per client in CSV format or MySQL/MariaDB/PostgreSQL/Timescale database - easy to   analyze</li> <li>Various REST API endpoints</li> <li>CLI tool</li> </ul> </li> <li> <p>Simple configuration -  single configuration file in YAML format</p> <ul> <li>Simple to maintain</li> <li>Simple to backup</li> </ul> </li> <li> <p>Simple installation/configuration -  blocky was designed for simple installation</p> <ul> <li>Stateless (no database, no temporary files)</li> <li>Docker image with Multi-arch support</li> <li>Single binary</li> <li>Supports x86-64 and ARM architectures -&gt; runs fine on Raspberry PI</li> <li>Community supported Helm chart for k8s deployment</li> </ul> </li> </ul>"},{"location":"#contribution","title":"Contribution","text":"<p>Issues, feature suggestions and pull requests are welcome! Blocky lives on GitHub.</p>"},{"location":"additional_information/","title":"Additional information","text":""},{"location":"additional_information/#print-current-configuration","title":"Print current configuration","text":"<p>To print runtime configuration / statistics, you can send <code>SIGUSR1</code> signal to running process.</p> <p>Summary</p> <p>Example output:</p> <pre><code>INFO server: current configuration:\nINFO server: -&gt; resolver: 'ClientNamesResolver'\nINFO server:      singleNameOrder = \"[2 1]\"\nINFO server:      externalResolver = \"upstream 'tcp+udp:192.168.178.1:53'\"\nINFO server:      cache item count = 7\nINFO server: -&gt; resolver: 'QueryLoggingResolver'\nINFO server:      logDir= \"/logs\"\nINFO server:      perClient = false\nINFO server:      logRetentionDays= 7\nINFO server: -&gt; resolver: 'MetricsResolver'\nINFO server:      metrics:\nINFO server:        Enable = true\nINFO server:        Path   = /metrics\nINFO server: -&gt; resolver: 'ConditionalUpstreamResolver'\nINFO server:      fritz.box = \"parallel upstreams 'upstream 'tcp+udp:192.168.178.1:53''\"\nINFO server: -&gt; resolver: 'CustomDNSResolver'\nINFO server: runtime information:\n...\nINFO server: MEM Alloc =                 9 MB\nINFO server: MEM HeapAlloc =             9 MB\nINFO server: MEM Sys =                  88 MB\nINFO server: MEM NumGC =              1533\nINFO server: RUN NumCPU =                4\nINFO server: RUN NumGoroutine =         18\n</code></pre> <p>Hint</p> <p>To send a signal to a process you can use <code>kill -s USR1 &lt;PID&gt;</code> or <code>docker kill -s SIGUSR1 blocky</code> for docker setup</p>"},{"location":"additional_information/#debug-profiling","title":"Debug / Profiling","text":"<p>If http listener is enabled, pprof endpoint (<code>/debug/pprof</code>) is enabled automatically.</p>"},{"location":"additional_information/#list-sources","title":"List sources","text":"<p>Some links/ideas for lists:</p>"},{"location":"additional_information/#denylists","title":"Denylists","text":"<ul> <li>https://github.com/StevenBlack/hosts</li> <li>https://github.com/nickspaargaren/no-google</li> <li>https://energized.pro/</li> <li>https://github.com/Perflyst/PiHoleBlocklist</li> <li>https://github.com/kboghdady/youTube_ads_4_pi-hole</li> <li>https://github.com/chadmayfield/my-pihole-blocklists</li> </ul> <p>Warning</p> <p>Use only denylists from the sources you trust!</p>"},{"location":"additional_information/#allowlists","title":"Allowlists","text":"<ul> <li>https://github.com/anudeepND/whitelist</li> </ul>"},{"location":"additional_information/#list-of-public-dns-servers","title":"List of public DNS servers","text":"<p>Warning</p> <p>DNS server provider has access to all your DNS queries (all visited domain names). Some DNS providers can use (tracking, analyzing, profiling etc.). It is recommended to use different DNS upstream servers in blocky to distribute your DNS queries over multiple providers.</p> <p>Please read the description before using the DNS server as upstream. Some of them provide already an ad-blocker, some filters other content. If you use external DNS server with included ad-blocker, you can't choose which domains should be blocked, and you can't use allowlisting.</p> <p>This is only a small excerpt of all free available DNS servers and should only be understood as an idee.</p> <p>Info</p> <p>I will NOT rate the DNS providers in the list. This list is sorted alphabetically.</p> <ul> <li>AdGuard</li> <li>CloudFlare</li> <li>Comodo</li> <li>DigitalCourage</li> <li>DigitaleGesellschaft</li> <li>Dismail</li> <li>dnsforge</li> <li>Google</li> <li>OpenDNS</li> <li>Quad9</li> <li>UncensoredDNS</li> </ul>"},{"location":"additional_information/#project-links","title":"Project links","text":""},{"location":"additional_information/#code-repository","title":"Code repository","text":"<p>Main: GitHub</p> <p>Mirror: Codeberg</p>"},{"location":"additional_information/#container-registry","title":"Container Registry","text":"<p>Main: Docker Hub</p> <p>Mirror: GitHub Container Registry</p>"},{"location":"additional_information/#developer-information","title":"Developer Information","text":""},{"location":"additional_information/#docker-images","title":"Docker Images","text":"<p>To enable Docker image creation on a GitHub fork create a secret with the name <code>DEVELOPMENT_DOCKER</code> and the value <code>true</code>. This will trigger a workflow on every push of a branch starting with <code>fb-</code> and create an image with the branch name.</p>"},{"location":"additional_information/#automatic-fork-sync","title":"Automatic fork sync","text":"<p>To enable automatic fork synchronisation create a secret with the name <code>FORK_SYNC_TOKEN</code> with an access token that has write permission to the fork repository. The enabled workflow will sync the main branch every 30 minutes with its upstream.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>This chapter describes all configuration options in <code>config.yaml</code>. You can download a reference file with all configuration properties as JSON.</p> reference configuration file <pre><code>upstreams:\n  init:\n    # Configure startup behavior.\n    # accepted: blocking, failOnError, fast\n    # default: blocking\n    strategy: fast\n  groups:\n    # these external DNS resolvers will be used. Blocky picks 2 random resolvers from the list for each query\n    # format for resolver: [net:]host:[port][/path][#commonname]. net could be empty (default, shortcut for tcp+udp), tcp+udp, tcp, udp, tcp-tls or https (DoH). If port is empty, default port will be used (53 for udp and tcp, 853 for tcp-tls, 443 for https (Doh))\n    # alternative format: DNS Stamp (sdns://...) - compact format that encodes all parameters including optional certificate hashes for automatic certificate pinning\n    # this configuration is mandatory, please define at least one external DNS resolver\n    default:\n      # example for tcp+udp IPv4 server (https://digitalcourage.de/)\n      - 5.9.164.112\n      # Cloudflare\n      - 1.1.1.1\n      # example for DNS-over-TLS server (DoT)\n      - tcp-tls:fdns1.dismail.de:853\n      # example for DNS-over-HTTPS (DoH)\n      - https://dns.digitale-gesellschaft.ch/dns-query\n      # example for DNS Stamp format (Plain DNS - Google 8.8.8.8)\n      - sdns://AAcAAAAAAAAABzguOC44Ljg\n      # example for DNS Stamp format (DoH - Digitale Gesellschaft)\n      - sdns://AgcAAAAAAAAADTE4NS45NS4yMTguNDKg9_WvKIAeh31986K-KP4UnzJ0p-0p8Tb9UDzjmMuoCw2g9XV9eG8XP2q1MZfsnCKQisBtKuTqoqW29Y678AOXod-gs14FlQz72CWfk3W6EBhwuMPEwOxaUpdX5jFn6d4mqeig7PBiC_ww1ETe9Xetxlw3UFpzui0v2eb_QcPtOtDWWg-gouMnQ2N22OdkBavp_siMtB3i1NA1DU6CkqUxGMS431ugkHjSGlbA4IkdkGIhtpkjMb3RcXLrDzPdoH1cZcbhTDmg1q1wTTQXThIIyVKqq5g16xwGaw3No7Ta1A9FE-jhglqgsl8vNpZ_c5TwmTeIWzM_qjVtcZ_qzzjM6fA1UADz4XSg5kS6aWPjNf52XLmXaxKxDrVClLQkd3ZMyzo6zKOssvygKq4_t78F5MgcQZTcpEUR1PmvMEeG7BrnIYQJz2Kgg1Wg1h2W6_s_oZCW4sAC42A79_2q77InBNqGaAYrvobtS5MgnUgyu0yNdyB7Jd4XWSaC78PKRfV53GZKDtXySPXJM5gcZG5zLmRpZ2l0YWxlLWdlc2VsbHNjaGFmdC5jaAovZG5zLXF1ZXJ5\n    # optional: use client name (with wildcard support: * - sequence of any characters, [0-9] - range)\n    # or single ip address / client subnet as CIDR notation\n    laptop*:\n      - 123.123.123.123\n  # optional: Determines what strategy blocky uses to choose the upstream servers.\n  # accepted: parallel_best, strict, random\n  # default: parallel_best\n  strategy: parallel_best\n  # optional: timeout to query the upstream resolver. Default: 2s\n  timeout: 2s\n  # optional: HTTP User Agent when connecting to upstreams. Default: none\n  userAgent: \"custom UA\"\n\n# optional: Determines how blocky will create outgoing connections. This impacts both upstreams, and lists.\n# accepted: dual, v4, v6\n# default: dual\nconnectIPVersion: dual\n\n# optional: custom IP address(es) for domain name (with all sub-domains). Multiple addresses must be separated by a comma\n# example: query \"printer.lan\" or \"my.printer.lan\" will return 192.168.178.3\ncustomDNS:\n  customTTL: 1h\n  # optional: if true (default), return empty result for unmapped query types (for example TXT, MX or AAAA if only IPv4 address is defined).\n  # if false, queries with unmapped types will be forwarded to the upstream resolver\n  filterUnmappedTypes: true\n  # optional: replace domain in the query with other domain before resolver lookup in the mapping\n  rewrite:\n    example.com: printer.lan\n  mapping:\n    printer.lan: 192.168.178.3,2001:0db8:85a3:08d3:1319:8a2e:0370:7344\n\n# optional: definition, which DNS resolver(s) should be used for queries to the domain (with all sub-domains). Multiple resolvers must be separated by a comma\n# Example: Query client.fritz.box will ask DNS server 192.168.178.1. This is necessary for local network, to resolve clients by host name\nconditional:\n  # optional: if false (default), return empty result if after rewrite, the mapped resolver returned an empty answer. If true, the original query will be sent to the upstream resolver\n  # Example: The query \"blog.example.com\" will be rewritten to \"blog.fritz.box\" and also redirected to the resolver at 192.168.178.1. If not found and if `fallbackUpstream` was set to `true`, the original query \"blog.example.com\" will be sent upstream.\n  # Usage: One usecase when having split DNS for internal and external (internet facing) users, but not all subdomains are listed in the internal domain.\n  fallbackUpstream: false\n  # optional: replace domain in the query with other domain before resolver lookup in the mapping\n  rewrite:\n    example.com: fritz.box\n  mapping:\n    fritz.box: 192.168.178.1\n    lan.net: 192.168.178.1,192.168.178.2\n\n# optional: use allow/denylists to block queries (for example ads, trackers, adult pages etc.)\nblocking:\n  # definition of denylist groups. Can be external link (http/https) or local file\n  denylists:\n    ads:\n      - https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt\n      - https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts\n      - http://sysctl.org/cameleon/hosts\n      - https://s3.amazonaws.com/lists.disconnect.me/simple_tracking.txt\n      - |\n        # inline definition with YAML literal block scalar style\n        someadsdomain.com\n        *.example.com\n    special:\n      - https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews/hosts\n  # definition of allowlist groups.\n  # Note: if the same group has both allow/denylists, allowlists take precedence. Meaning if a domain is both blocked and allowed, it will be allowed.\n  # If a group has only allowlist entries, only domains from this list are allowed, and all others be blocked.\n  allowlists:\n    ads:\n      - allowlist.txt\n      - |\n        # inline definition with YAML literal block scalar style\n        # hosts format\n        allowlistdomain.com\n        # this is a regex\n        /^banners?[_.-]/\n  # definition: which groups should be applied for which client\n  clientGroupsBlock:\n    # default will be used, if no special definition for a client name exists\n    default:\n      - ads\n      - special\n    # use client name (with wildcard support: * - sequence of any characters, [0-9] - range)\n    # or single ip address / client subnet as CIDR notation\n    laptop*:\n      - ads\n    192.168.178.1/24:\n      - special\n  # which response will be sent, if query is blocked:\n  # zeroIp: 0.0.0.0 will be returned (default)\n  # nxDomain: return NXDOMAIN as return code\n  # comma separated list of destination IP addresses (for example: 192.100.100.15, 2001:0db8:85a3:08d3:1319:8a2e:0370:7344). Should contain ipv4 and ipv6 to cover all query types. Useful with running web server on this address to display the \"blocked\" page.\n  blockType: zeroIp\n  # optional: TTL for answers to blocked domains\n  # default: 6h\n  blockTTL: 1m\n  # optional: Configure how lists, AKA sources, are loaded\n  loading:\n    # optional: list refresh period in duration format.\n    # Set to a value &lt;= 0 to disable.\n    # default: 4h\n    refreshPeriod: 24h\n    # optional: Applies only to lists that are downloaded (HTTP URLs).\n    downloads:\n      # optional: timeout for list download (each url). Use large values for big lists or slow internet connections\n      # default: 5s\n      timeout: 60s\n      # optional: timeout for list write to disk (each url). Use larger values for big lists or in constrained environments\n      # default: 20s\n      writeTimeout: 60s\n      # optional: timeout for reading the download (each url). Use large values for big lists or in constrained environments\n      # To disable this timeout, set to 0.\n      # default: 20s\n      readTimeout: 60s\n      # optional: timeout for reading request headers for the download (each url). Use large values for slow internet connections\n      # to disable, set to -1.\n      # default: 20s\n      readHeaderTimeout: 60s\n      # optional: Maximum download attempts\n      # default: 3\n      attempts: 5\n      # optional: Time between the download attempts\n      # default: 500ms\n      cooldown: 10s\n    # optional: Maximum number of lists to process in parallel.\n    # default: 4\n    concurrency: 16\n    # Configure startup behavior.\n    # accepted: blocking, failOnError, fast\n    # default: blocking\n    strategy: failOnError\n    # Number of errors allowed in a list before it is considered invalid.\n    # A value of -1 disables the limit.\n    # default: 5\n    maxErrorsPerSource: 5\n\n# optional: configuration for caching of DNS responses\ncaching:\n  # duration how long a response must be cached (min value).\n  # If &lt;=0, use response's TTL, if &gt;0 use this value, if TTL is smaller\n  # Default: 0\n  minTime: 5m\n  # duration how long a response must be cached (max value).\n  # If &lt;0, do not cache responses\n  # If 0, use TTL\n  # If &gt; 0, use this value, if TTL is greater\n  # Default: 0\n  maxTime: 30m\n  # Max number of cache entries (responses) to be kept in cache (soft limit). Useful on systems with limited amount of RAM.\n  # Default (0): unlimited\n  maxItemsCount: 0\n  # if true, will preload DNS results for often used queries (default: names queried more than 5 times in a 2-hour time window)\n  # this improves the response time for often used queries, but significantly increases external traffic\n  # default: false\n  prefetching: true\n  # prefetch track time window (in duration format)\n  # default: 120\n  prefetchExpires: 2h\n  # name queries threshold for prefetch\n  # default: 5\n  prefetchThreshold: 5\n  # Max number of domains to be kept in cache for prefetching (soft limit). Useful on systems with limited amount of RAM.\n  # Default (0): unlimited\n  prefetchMaxItemsCount: 0\n  # Time how long negative results (NXDOMAIN response or empty result) are cached. A value of -1 will disable caching for negative results.\n  # Default: 30m\n  cacheTimeNegative: 30m\n\n# optional: configuration of client name resolution\nclientLookup:\n  # optional: this DNS resolver will be used to perform reverse DNS lookup (typically local router)\n  upstream: 192.168.178.1\n  # optional: some routers return multiple names for client (host name and user defined name). Define which single name should be used.\n  # Example: take second name if present, if not take first name\n  singleNameOrder:\n    - 2\n    - 1\n  # optional: custom mapping of client name to IP addresses. Useful if reverse DNS does not work properly or just to have custom client names.\n  clients:\n    laptop:\n      - 192.168.178.29\n\n# optional: configuration for prometheus metrics endpoint\nprometheus:\n  # enabled if true\n  enable: true\n  # url path, optional (default '/metrics')\n  path: /metrics\n\n# optional: write query information (question, answer, client, duration etc.) to daily csv file\nqueryLog:\n  # optional one of: mysql, postgresql, timescale, csv, csv-client. If empty, log to console\n  type: mysql\n  # directory (should be mounted as volume in docker) for csv, db connection string for mysql/postgresql\n  target: db_user:db_password@tcp(db_host_or_ip:3306)/db_name?charset=utf8mb4&amp;parseTime=True&amp;loc=Local\n  #postgresql target: postgres://user:password@db_host_or_ip:5432/db_name\n  # if &gt; 0, deletes log files which are older than ... days\n  logRetentionDays: 7\n  # optional: Max attempts to create specific query log writer, default: 3\n  creationAttempts: 1\n  # optional: Time between the creation attempts, default: 2s\n  creationCooldown: 2s\n  # optional: Which fields should be logged. You can choose one or more from: clientIP, clientName, responseReason, responseAnswer, question, duration. If not defined, it logs all fields\n  fields:\n    - clientIP\n    - duration\n  # optional: Interval to write data in bulk to the external database, default: 30s\n  flushInterval: 30s\n\n# optional: Blocky can synchronize its cache and blocking state between multiple instances through redis.\nredis:\n  # Server address and port or master name if sentinel is used\n  address: redismaster\n  # Username if necessary\n  username: usrname\n  # Password if necessary\n  password: passwd\n  # Database, default: 0\n  database: 2\n  # Connection is required for blocky to start. Default: false\n  required: true\n  # Max connection attempts, default: 3\n  connectionAttempts: 10\n  # Time between the connection attempts, default: 1s\n  connectionCooldown: 3s\n  # Sentinal username if necessary\n  sentinelUsername: usrname\n  # Sentinal password if necessary\n  sentinelPassword: passwd\n  # List with address and port of sentinel hosts(sentinel is activated if at least one sentinel address is configured)\n  sentinelAddresses:\n    - redis-sentinel1:26379\n    - redis-sentinel2:26379\n    - redis-sentinel3:26379\n\n# optional: Mininal TLS version that the DoH and DoT server will use\nminTlsServeVersion: 1.3\n\n# if https port &gt; 0: path to cert and key file for SSL encryption. if not set, self-signed certificate will be generated\n#certFile: server.crt\n#keyFile: server.key\n\n# optional: use these DNS servers to resolve denylist urls and upstream DNS servers. It is useful if no system DNS resolver is configured, and/or to encrypt the bootstrap queries.\nbootstrapDns:\n  - tcp+udp:1.1.1.1\n  - https://1.1.1.1/dns-query\n  - upstream: https://dns.digitale-gesellschaft.ch/dns-query\n    ips:\n      - 185.95.218.42\n\n# optional: drop all queries with following query types. Default: empty\nfiltering:\n  queryTypes:\n    - AAAA\n\n# optional: return NXDOMAIN for queries that are not FQDNs.\nfqdnOnly:\n  # default: false\n  enable: true\n\n# optional: if path defined, use this file for query resolution (A, AAAA and rDNS). Default: empty\nhostsFile:\n  # optional: Hosts files to parse\n  sources:\n    - /etc/hosts\n    - https://example.com/hosts\n    - |\n      # inline hosts\n      127.0.0.1 example.com\n  # optional: TTL, default: 1h\n  hostsTTL: 30m\n  # optional: Whether loopback hosts addresses (127.0.0.0/8 and ::1) should be filtered or not\n  # default: false\n  filterLoopback: true\n  # optional: Configure how sources are loaded\n  loading:\n    # optional: file refresh period in duration format.\n    # Set to a value &lt;= 0 to disable.\n    # default: 4h\n    refreshPeriod: 24h\n    # optional: Applies only to files that are downloaded (HTTP URLs).\n    downloads:\n      # optional: timeout for file download (each url). Use large values for big files or slow internet connections\n      # default: 5s\n      timeout: 60s\n      # optional: Maximum download attempts\n      # default: 3\n      attempts: 5\n      # optional: Time between the download attempts\n      # default: 500ms\n      cooldown: 10s\n    # optional: Maximum number of files to process in parallel.\n    # default: 4\n    concurrency: 16\n    # Configure startup behavior.\n    # accepted: blocking, failOnError, fast\n    # default: blocking\n    strategy: failOnError\n    # Number of errors allowed in a file before it is considered invalid.\n    # A value of -1 disables the limit.\n    # default: 5\n    maxErrorsPerSource: 5\n\n# optional: ports configuration\nports:\n  # optional: DNS listener port(s) and bind ip address(es)\n  # default: 53 (UDP and TCP)\n  # example: [53, :53, 127.0.0.1:53, [::1]:53]\n  dns:\n    - 53\n    - localhost:5353\n  # optional: Port(s) and bind ip address(es) for DoT (DNS-over-TLS) listener.\n  #           Supports the same formats as `dns` above.\n  # default: none\n  # example: [853, :853, 127.0.0.1:853, [::1]:853]\n  tls: 853\n  # optional: Port(s) and optional bind ip address(es) to serve HTTPS used for prometheus metrics, pprof, REST API, DoH...\n  # example: [443, :443, 127.0.0.1:443, [::1]:443]\n  https: 443\n  # optional: Port(s) and optional bind ip address(es) to serve HTTP used for prometheus metrics, pprof, REST API, DoH...\n  # example: [4000, :4000, 127.0.0.1:4000, [::1]:4000]\n  http: 4000\n  # optional: URL path for DoH queries.\n  # default: /dns-query\n  dohPath: /dns-query\n\n# optional: logging configuration\nlog:\n  # optional: Log level (one from trace, debug, info, warn, error). Default: info\n  level: info\n  # optional: Log format (text or json). Default: text\n  format: text\n  # optional: log timestamps. Default: true\n  timestamp: true\n  # optional: obfuscate log output (replace all alphanumeric characters with *) for user sensitive data like request domains or responses to increase privacy. Default: false\n  privacy: false\n\n# optional: add EDE error codes to dns response\nede:\n  # enabled if true, Default: false\n  enable: true\n\n# optional: configure optional Special Use Domain Names (SUDN)\nspecialUseDomains:\n  # optional: block recomended private TLDs\n  # default: true\n  rfc6762-appendixG: true\n  enable: true\n\n# optional: configure extended client subnet (ECS) support\necs:\n  # optional: if the request ecs option with a max sice mask the address will be used as client ip\n  useAsClient: true\n  # optional: if the request contains a ecs option it will be forwarded to the upstream resolver\n  forward: true\n\n# optional: DNSSEC validation configuration\n# DNSSEC (Domain Name System Security Extensions) provides cryptographic authentication\n# of DNS data to protect against cache poisoning and man-in-the-middle attacks\ndnssec:\n  # Enable DNSSEC validation. When enabled, Blocky will:\n  # - Set the DNSSEC OK (DO) bit on upstream queries\n  # - Validate cryptographic signatures (RRSIG) in DNS responses\n  # - Verify the chain of trust from root to queried domain\n  # - Validate authenticated denial of existence (NSEC/NSEC3 for NXDOMAIN/NODATA)\n  # - Validate wildcard expansions per RFC 4035 \u00a75.3.4\n  # - Return SERVFAIL for responses with invalid DNSSEC signatures (Bogus)\n  # - Set the Authenticated Data (AD) flag only after successful validation\n  #\n  # default: false\n  validate: true\n\n  # Maximum domain label depth for chain of trust validation\n  # Prevents DoS with deeply nested domains (e.g., a.b.c.d.e.f.g.h.i.j.example.com)\n  # default: 10\n  maxChainDepth: 10\n\n  # How long to cache validation results (in hours)\n  # Improves performance by avoiding repeated validation of the same domains\n  # default: 1\n  cacheExpirationHours: 1\n\n  # Maximum upstream DNS queries per validation request\n  # Protects against DoS attacks with queries requiring many upstream lookups\n  # (e.g., deeply nested delegation chains requiring DNSKEY + DS queries per level)\n  # Validation will fail if budget is exhausted\n  # default: 30\n  maxUpstreamQueries: 30\n\n  # Maximum NSEC3 hash iterations allowed during validation\n  # NSEC3 is used for authenticated denial of existence in DNSSEC zones\n  # Higher iteration counts increase CPU cost, making DoS attacks possible\n  # RFC 5155 \u00a710.3 recommends rejecting responses with excessive iterations\n  # default: 150\n  maxNSEC3Iterations: 150\n\n  # Clock skew tolerance in seconds for signature timestamp validation\n  # Allows validation to succeed even if the system clock is off by this amount\n  # RFC 6781 \u00a74.1.2 recommends accounting for clock skew in deployment environments\n  # This is especially important for:\n  # - Virtual machines (clock drift after suspend/resume)\n  # - Containers (clock sync with host)\n  # - IoT/embedded devices (no NTP, battery-backed RTC)\n  # - Systems during NTP synchronization\n  # Default matches industry standard validators (Unbound, BIND)\n  # - 300 (5 minutes): Conservative, handles typical NTP drift\n  # - 3600 (1 hour): Lenient, handles timezone/DST issues (default)\n  # - 7200 (2 hours): Very lenient, for systems with significant clock problems\n  # default: 3600 (1 hour)\n  clockSkewToleranceSec: 3600\n\n  # optional: Custom trust anchors (DNSKEY records) for DNSSEC validation\n  # By default, Blocky uses the latest IANA root trust anchors (KSK-2017 and KSK-2024)\n  # Only override this for testing, private zones, or lab environments\n  # Format: DNS record format (DNSKEY or DS records)\n  # WARNING: Specifying custom trust anchors replaces the default root trust anchors\n  # default: [] (use built-in root trust anchors)\n  trustAnchors:\n    # Example: Custom DNSKEY record for a private zone\n    - \"example.com. 86400 IN DNSKEY 257 3 8 AwEAAaz/tAm8yTn4Mfeh5eyI96WSVexTBAvkMgJzkKTO...\"\n    # Example: DS record format (for parent zone validation)\n    - \"subdomain.example.com. 3600 IN DS 12345 8 2 1234567890ABCDEF...\"\n\n# optional: DNS64 configuration\n# DNS64 (RFC 6147) allows IPv6-only clients to access IPv4-only services by\n# synthesizing AAAA (IPv6) records from A (IPv4) records. This is critical for\n# IPv6-only networks (cellular, IoT, modern datacenters) that need to reach\n# legacy IPv4-only destinations.\ndns64:\n  # Enable DNS64 synthesis\n  # WARNING: Do NOT enable if filtering.queryTypes contains AAAA, as all AAAA\n  # queries will be filtered before reaching DNS64 (making DNS64 ineffective)\n  # default: false\n  enable: false\n\n  # optional: DNS64 prefixes for IPv4-to-IPv6 address synthesis\n  # Multiple prefixes allow for load balancing or redundancy across multiple\n  # NAT64 gateways. DNS64 will synthesize one AAAA record per prefix per A record.\n  #\n  # Format: IPv6 prefix in CIDR notation\n  # Valid prefix lengths (per RFC 6052): /32, /40, /48, /56, /64, /96\n  # - /96 is most common (well-known prefix 64:ff9b::/96)\n  # - Shorter prefixes (/32, /40, etc.) allow more flexibility in address assignment\n  #\n  # default: [64:ff9b::/96] (RFC 6052 well-known prefix)\n  #\n  # IMPORTANT: Prefixes must not overlap. Overlapping prefixes will be rejected.\n  prefixes:\n    - 64:ff9b::/96\n\n  # optional: DNS64 exclusion set\n  # DNS64 will NOT synthesize AAAA records if the response already contains\n  # AAAA records that are NOT in the exclusion set.\n  #\n  # If not specified (recommended), uses default exclusion set:\n  # - IPv4-mapped IPv6 addresses (::ffff:0:0/96) - RFC 6147 requirement\n  # - Loopback address (::1/128) - RFC 6147 recommendation\n  # - Link-local addresses (fe80::/10) - RFC 6147 recommendation\n  # - Configured DNS64 prefixes - prevents synthesis loops\n  #\n  # Custom exclusion set (advanced use only):\n  # WARNING: If you configure a custom exclusion set, you are responsible for\n  # including all necessary ranges. The configured prefixes are NOT automatically\n  # added when using a custom exclusion set.\n  #\n  # default: [::ffff:0:0/96, ::1/128, fe80::/10] + configured prefixes\n  #\n  # Example custom exclusion set:\n  # exclusionSet:\n  #   - ::ffff:0:0/96  # IPv4-mapped (REQUIRED by RFC)\n  #   - ::1/128        # Loopback (recommended)\n  #   - fe80::/10      # Link-local (recommended)\n  #   - 64:ff9b::/96   # Your configured prefix (recommended to prevent loops)\n  #   - 2001:db8::/32  # Custom exclusion range\n  #\n</code></pre>"},{"location":"configuration/#basic-configuration","title":"Basic configuration","text":"Parameter Type Mandatory Default value Description certFile path no Path to cert and key file for SSL encryption (DoH and DoT); if empty, self-signed certificate is generated keyFile path no Path to cert and key file for SSL encryption (DoH and DoT); if empty, self-signed certificate is generated minTlsServeVersion string no 1.2 Minimum TLS version that the DoT and DoH server use to serve those encrypted DNS requests connectIPVersion enum (dual, v4, v6) no dual IP version to use for outgoing connections (dual, v4, v6) <p>Example</p> <pre><code>minTlsServeVersion: 1.1\nconnectIPVersion: v4\n</code></pre>"},{"location":"configuration/#ports-addresses-configuration","title":"Ports &amp; addresses configuration","text":"<p>All values in this section are optional.</p> Parameter Type Default value Description ports.dns One or more [IP]:Port 53 Listen address for DNS (TCP and UDP). Example: <code>53</code>, <code>:53</code>, <code>192.168.0.1:53</code>, <code>[53, \"[::1]:53\"]</code> ports.tls One or more [IP]:Port Listen address for DoT (DNS-over-TLS). Example: <code>83</code>, <code>:853</code>, <code>192.168.0.1:853</code>, <code>[853, \"[::1]:853\"]</code> ports.http One or more [IP]:Port Listen address for HTTP used for prometheus metrics, pprof, REST API, DoH... Example: <code>4000</code>, <code>:4000</code>, <code>192.168.0.1:4000</code>, <code>[4000, \"[::1]:4000\"]</code> ports.https One or more [IP]:Port Listen address for HTTPS used for prometheus metrics, pprof, REST API, DoH... Example: <code>443</code>, <code>:443</code>, <code>192.168.0.1:443</code>, <code>[443, \"[::1]:443\"]</code> ports.dohPath string /dns-query URL path for DoH queries. <p>Example</p> <pre><code>ports:\n  dns: 53\n  tls: [853, \"[::1]:853\"]\n  http:\n    - 80\n    - 4000\n  https: 443\n</code></pre>"},{"location":"configuration/#logging-configuration","title":"Logging configuration","text":"<p>All logging options are optional.</p> Parameter Type Default value Description log.level enum (trace, debug, info, warn, error) info Log level log.format enum (text, json) text Log format (text or json). log.timestamp bool true Log timestamps (true or false). log.privacy bool false Obfuscate log output (replace all alphanumeric characters with *) for user sensitive data like request domains or responses to increase privacy. <p>Example</p> <pre><code>log:\n  level: debug\n  format: json\n  timestamp: false\n  privacy: true\n</code></pre>"},{"location":"configuration/#init-strategy","title":"Init Strategy","text":"<p>A couple of features use an \"init/loading strategy\" which configures behavior at Blocky startup. This applies to all of them. The default strategy is blocking.</p> strategy Description blocking Initialization happens before DNS resolution starts. Any errors are logged, but Blocky continues running if possible. failOnError Like blocking but Blocky will exit with an error if initialization fails. fast Blocky starts serving DNS immediately and initialization happens in the background. The feature requiring initialization will enable later on (if it succeeds)."},{"location":"configuration/#upstreams-configuration","title":"Upstreams configuration","text":"Parameter Type Mandatory Default value Description upstreams.groups map of name to upstream yes Upstream DNS servers to use, in groups. upstreams.init.strategy enum (blocking, failOnError, fast) no blocking See Init Strategy and below. upstreams.strategy enum (parallel_best, random, strict) no parallel_best Upstream server usage strategy. upstreams.timeout duration no 2s Upstream connection timeout. upstreams.userAgent string no HTTP User Agent when connecting to upstreams. <p>For <code>init.strategy</code>, the \"init\" is testing the given resolvers for each group. The potentially fatal error, depending on the strategy, is if a group has no functional resolvers.</p>"},{"location":"configuration/#upstream-groups","title":"Upstream Groups","text":"<p>To resolve a DNS query, blocky needs external public or private DNS resolvers. Blocky supports DNS resolvers with following network protocols (net part of the resolver URL):</p> <ul> <li>tcp+udp (UDP and TCP, dependent on query type)</li> <li>https (aka DoH)</li> <li>tcp-tls (aka DoT)</li> </ul> <p>Hint</p> <p>You can (and should!) configure multiple DNS resolvers. Per default blocky uses the <code>parallel_best</code> upstream strategy where blocky picks 2 random resolvers from the list for each query and returns the answer from the fastest one.</p> <p>Each resolver must be defined as a string in following format: <code>[net:]host:[port][/path][#commonName]</code>.</p> Parameter Type Mandatory Default value net enum (tcp+udp, tcp-tls or https) no tcp+udp host IP or hostname yes port int (1 - 65535) no 53 for udp/tcp, 853 for tcp-tls and 443 for https commonName string no the host value <p>The <code>commonName</code> parameter overrides the expected certificate common name value used for verification.</p>"},{"location":"configuration/#dns-stamp-format","title":"DNS Stamp Format","text":"<p>As an alternative to the traditional format, Blocky supports DNS Stamps (<code>sdns://...</code>), which encode all connection parameters in a compact, shareable format.</p> <p>DNS Stamps are standardized URIs (following IETF draft-denis-dns-stamps) that include protocol, address, hostname, path, and optional certificate hashes in a single string.</p> <p>Format: <code>sdns://base64url(payload)</code></p> <p>Supported Protocols:</p> <ul> <li>Plain DNS (<code>sdns://AA...</code>)</li> <li>DNS-over-HTTPS (<code>sdns://Ag...</code>)</li> <li>DNS-over-TLS (<code>sdns://Aw...</code>)</li> </ul> <p>Benefits:</p> <ul> <li>Compact: Single string encodes all parameters</li> <li>Portable: Easy to share and copy</li> <li>Secure: Includes certificate hashes for automatic certificate pinning</li> <li>Standardized: Following IETF specification</li> </ul> <p>Examples:</p> <pre><code>upstreams:\n  groups:\n    default:\n      # Traditional format\n      - 8.8.8.8\n      - https://dns.google/dns-query\n      - tcp-tls:1.1.1.1:853\n\n      # DNS Stamp format (equivalent servers)\n      - sdns://AAcAAAAAAAAABzguOC44Ljg  # Google DNS\n      - sdns://AgcAAAAAAAAADTE4NS45NS4yMTguNDKg9_WvKIAeh31986K-KP4UnzJ0p-0p8Tb9UDzjmMuoCw2g9XV9eG8XP2q1MZfsnCKQisBtKuTqoqW29Y678AOXod-gs14FlQz72CWfk3W6EBhwuMPEwOxaUpdX5jFn6d4mqeig7PBiC_ww1ETe9Xetxlw3UFpzui0v2eb_QcPtOtDWWg-gouMnQ2N22OdkBavp_siMtB3i1NA1DU6CkqUxGMS431ugkHjSGlbA4IkdkGIhtpkjMb3RcXLrDzPdoH1cZcbhTDmg1q1wTTQXThIIyVKqq5g16xwGaw3No7Ta1A9FE-jhglqgsl8vNpZ_c5TwmTeIWzM_qjVtcZ_qzzjM6fA1UADz4XSg5kS6aWPjNf52XLmXaxKxDrVClLQkd3ZMyzo6zKOssvygKq4_t78F5MgcQZTcpEUR1PmvMEeG7BrnIYQJz2Kgg1Wg1h2W6_s_oZCW4sAC42A79_2q77InBNqGaAYrvobtS5MgnUgyu0yNdyB7Jd4XWSaC78PKRfV53GZKDtXySPXJM5gcZG5zLmRpZ2l0YWxlLWdlc2VsbHNjaGFmdC5jaAovZG5zLXF1ZXJ5  # Digitale Gesellschaft DoH\n</code></pre> <p>Certificate Pinning:</p> <p>DNS stamps can include SHA256 certificate hashes for enhanced security. When present, Blocky automatically validates the server's certificate against these hashes, preventing MITM attacks even if a Certificate Authority is compromised.</p> <p>This is transparent to the user - if a DNS stamp includes certificate hashes, pinning is automatically enabled.</p> <p>Creating DNS Stamps:</p> <p>Use the DNS Stamp Calculator to create stamps for your DNS servers.</p> <p>Note</p> <ul> <li>DNSCrypt and DNS-over-QUIC protocols are not yet supported</li> <li>Traditional and DNS stamp formats can be mixed in the same configuration</li> <li>DNS stamps with certificate hashes provide additional security through automatic certificate pinning</li> </ul> <p>Note</p> <p>Blocky needs at least the configuration of the default group with at least one upstream DNS server. This group will be used as a fallback, if no client specific resolver configuration is available.</p> <p>See List of public DNS servers if you need some ideas, which public free DNS server you could use.</p> <p>You can specify multiple upstream groups (additional to the <code>default</code> group) to use different upstream servers for different clients, based on client name (see Client name lookup), client IP address or client subnet (as CIDR).</p> <p>Tip</p> <p>You can use <code>*</code> as wildcard for the sequence of any character or <code>[0-9]</code> as number range</p> <p>Example</p> <pre><code>upstreams:\n  groups:\n    default:\n      - 5.9.164.112\n      - 1.1.1.1\n      - tcp-tls:fdns1.dismail.de:853\n      - https://dns.digitale-gesellschaft.ch/dns-query\n    laptop*:\n      - 123.123.123.123\n    10.43.8.67/28:\n      - 1.1.1.1\n      - 9.9.9.9\n</code></pre> <p>The above example results in:</p> <ul> <li><code>123.123.123.123</code> as the only upstream DNS resolver for clients with a name starting with \"laptop\"</li> <li><code>1.1.1.1</code> and <code>9.9.9.9</code> for all clients in the subnet <code>10.43.8.67/28</code></li> <li>4 resolvers (default) for all others clients.</li> </ul> <p>The logic determining what group a client belongs to follows a strict order: IP, client name, CIDR</p> <p>If a client matches multiple client name or CIDR groups, a warning is logged and the first found group is used.</p>"},{"location":"configuration/#upstream-connection-timeout","title":"Upstream connection timeout","text":"<p>Blocky will wait 2 seconds (default value) for the response from the external upstream DNS server. You can change this value by setting the <code>timeout</code> configuration parameter (in duration format).</p> <p>Example</p> <pre><code>upstreams:\n  timeout: 5s\n  groups:\n    default:\n      - 46.182.19.48\n      - 80.241.218.68\n</code></pre>"},{"location":"configuration/#upstream-strategy","title":"Upstream strategy","text":"<p>Blocky supports different upstream strategies (default <code>parallel_best</code>) that determine how and to which upstream DNS servers requests are forwarded.</p> <p>Currently available strategies:</p> <ul> <li><code>parallel_best</code>: blocky picks 2 random (weighted) resolvers from the upstream group for each query and returns the answer from the fastest one.   If an upstream failed to answer within the last hour, it is less likely to be chosen for the race.   This improves your network speed and increases your privacy - your DNS traffic will be distributed over multiple providers.   (When using 10 upstream servers, each upstream will get on average 20% of the DNS requests)</li> <li><code>random</code>: blocky picks one random (weighted) resolver from the upstream group for each query and if successful, returns its response.   If the selected resolver fails to respond, a second one is picked to which the query is sent.   The weighting is identical to the <code>parallel_best</code> strategy.   Although the <code>random</code> strategy might be slower than the <code>parallel_best</code> strategy, it offers more privacy since each request is sent to a single upstream.</li> <li><code>strict</code>: blocky forwards the request in a strict order. If the first upstream does not respond, the second is asked, and so on.</li> </ul> <p>Example</p> <pre><code>upstreams:\n  strategy: strict\n  groups:\n    default:\n      - 1.2.3.4\n      - 9.8.7.6\n</code></pre>"},{"location":"configuration/#bootstrap-dns-configuration","title":"Bootstrap DNS configuration","text":"<p>These DNS servers are used to resolve upstream DoH and DoT servers that are specified as host names, and list domains. It is useful if no system DNS resolver is configured, and/or to encrypt the bootstrap queries.</p> Parameter Type Mandatory Default value Description upstream Upstream (see above) no ips List of IPs yes, if upstream is DoT/DoH Only valid if upstream is DoH or DoT <p>When using an upstream specified by IP, and not by hostname, you can write only the upstream and skip <code>ips</code>.</p> <p>Note</p> <p>Works only on Linux/*nix OS due to golang limitations under Windows.</p> <p>Example</p> <pre><code>    bootstrapDns:\n      - upstream: tcp-tls:dns.example.com\n        ips:\n        - 123.123.123.123\n      - upstream: https://234.234.234.234/dns-query\n</code></pre>"},{"location":"configuration/#filtering","title":"Filtering","text":"<p>Under certain circumstances, it may be useful to filter some types of DNS queries. You can define one or more DNS query types, all queries with these types will be dropped (empty answer will be returned).</p> <p>Example</p> <pre><code>filtering:\n  queryTypes:\n    - AAAA\n</code></pre> <p>This configuration will drop all 'AAAA' (IPv6) queries.</p>"},{"location":"configuration/#fqdn-only","title":"FQDN only","text":"<p>In domain environments, it may be useful to only respond to FQDN requests. If this option is enabled blocky will respond immediately with NXDOMAIN if the request is not a valid FQDN. The request is therefore not processed further by other options like custom or conditional. Please be aware that by enabling this your resolution will break unless every query is for a fully qualified domain name.</p> <p>Example</p> <pre><code>fqdnOnly:\n  enable: true\n</code></pre>"},{"location":"configuration/#custom-dns","title":"Custom DNS","text":"<p>You can define your own domain name mappings for local DNS resolution. This is useful for creating user-friendly names for network devices, defining domain names for local services, or creating your own DNS zone.</p> <p>Custom DNS supports multiple record types (A, AAAA, CNAME, TXT, SRV) and provides automatic reverse DNS lookups for defined IP addresses.</p> Parameter Type Mandatory Default value Description customTTL duration used for simple mappings (no unit is minutes) no 1h Time-to-live for DNS records defined in the mapping section rewrite string: string (domain: domain) no Domain rewriting rules applied before DNS resolution mapping string: string (hostname: address or CNAME) no Simple domain to IP/CNAME mappings zone string containing a DNS Zone no DNS zone file content for more complex configurations filterUnmappedTypes boolean no true Whether to filter query types that aren't defined for a domain or forward them to upstream"},{"location":"configuration/#simple-mapping","title":"Simple Mapping","text":"<p>The <code>mapping</code> parameter allows you to define simple domain-to-IP mappings. You can specify multiple IP addresses for a single domain by separating them with commas.</p> <p>Example</p> <pre><code>customDNS:\n  customTTL: 1h\n  mapping:\n    printer.lan: 192.168.178.3\n    otherdevice.lan: 192.168.178.15,2001:0db8:85a3:08d3:1319:8a2e:0370:7344\n</code></pre> <p>This configuration will resolve: - <code>printer.lan</code> to IPv4 address <code>192.168.178.3</code> - <code>otherdevice.lan</code> to both IPv4 address <code>192.168.178.15</code> and IPv6 address <code>2001:0db8:85a3:08d3:1319:8a2e:0370:7344</code></p>"},{"location":"configuration/#subdomain-resolution","title":"Subdomain Resolution","text":"<p>Custom DNS automatically resolves subdomains of defined domains. For example, with the above configuration, queries for <code>my.printer.lan</code> or <code>any.subdomain.of.printer.lan</code> will also resolve to <code>192.168.178.3</code>.</p>"},{"location":"configuration/#domain-rewriting","title":"Domain Rewriting","text":"<p>With the optional <code>rewrite</code> parameter, you can replace part of a domain query with another string before resolution is performed:</p> <p>Example</p> <pre><code>customDNS:\n  rewrite:\n    home: lan\n    example.com: example-rewrite.com\n  mapping:\n    printer.lan: 192.168.178.3\n    example-rewrite.com: 1.2.3.4\n</code></pre> <p>With this configuration: - A query for <code>printer.home</code> will be rewritten to <code>printer.lan</code> and return <code>192.168.178.3</code> - A query for <code>sub.example.com</code> will be rewritten to <code>sub.example-rewrite.com</code> and return <code>1.2.3.4</code></p>"},{"location":"configuration/#zone-file","title":"Zone File","text":"<p>For more complex configurations, you can use the <code>zone</code> parameter to define a DNS zone file:</p> <p>Example</p> <pre><code>customDNS:\n  zone: |\n    $ORIGIN example.com.\n    www 3600 A 1.2.3.4\n    www 3600 AAAA 2001:db8:85a3::8a2e:370:7334\n    @ 3600 CNAME www\n</code></pre> <p>The zone file supports standard DNS zone file syntax including: - <code>$ORIGIN</code> - sets the origin for relative domain names - <code>$TTL</code> - sets the default TTL for records in the zone - <code>$INCLUDE</code> - includes another zone file relative to the blocky executable - <code>$GENERATE</code> - generates a range of records</p> <p>For records defined using the <code>zone</code> parameter, the <code>customTTL</code> parameter is unused. Instead, the TTL is defined in the zone directly.</p>"},{"location":"configuration/#cname-resolution","title":"CNAME Resolution","text":"<p>When a CNAME record is defined and a query matches that record, blocky will: 1. Return the CNAME record in the answer 2. Additionally resolve the target of the CNAME and include those records in the answer 3. Protect against CNAME loops (where CNAMEs point to each other in a loop)</p>"},{"location":"configuration/#reverse-dns","title":"Reverse DNS","text":"<p>Blocky automatically creates reverse DNS (PTR) records for all defined A and AAAA records. This allows reverse lookups from IP addresses to domain names.</p>"},{"location":"configuration/#filtering-unmapped-types","title":"Filtering Unmapped Types","text":"<p>With <code>filterUnmappedTypes = true</code> (default), blocky will filter all queries with unmapped types. For example, if you only define an A record for <code>printer.lan</code>, an AAAA query for the same domain will return an empty result.</p> <p>With <code>filterUnmappedTypes = false</code>, unmapped type queries will be forwarded to the upstream DNS server. For example, an AAAA query for <code>printer.lan</code> (when only an A record is defined) will be sent to the upstream resolver.</p>"},{"location":"configuration/#conditional-dns-resolution","title":"Conditional DNS resolution","text":"<p>You can define, which DNS resolver(s) should be used for queries for the particular domain (with all subdomains). This is for example useful, if you want to reach devices in your local network by the name. Since only your router know which hostname belongs to which IP address, all DNS queries for the local network should be redirected to the router.</p> <p>The optional parameter <code>rewrite</code> behaves the same as with custom DNS.</p> <p>The optional parameter <code>fallbackUpstream</code>, if false (default), return empty result if after rewrite, the mapped resolver returned an empty answer. If true, the original query will be sent to the upstream resolver.</p> <p>Usage: One usecase when having split DNS for internal and external (internet facing) users, but not all subdomains are listed in the internal domain</p> <p>Example</p> <pre><code>conditional:\n  fallbackUpstream: false\n  rewrite:\n    example.com: fritz.box\n    replace-me.com: with-this.com\n  mapping:\n    fritz.box: 192.168.178.1\n    lan.net: 192.170.1.2,192.170.1.3\n    # for reverse DNS lookups of local devices\n    178.168.192.in-addr.arpa: 192.168.178.1\n    # for all unqualified hostnames\n    .: 168.168.0.1\n</code></pre> <p>Tip</p> <p>You can use <code>.</code> as wildcard for all non full qualified domains (domains without dot)</p> <p>In this example, a DNS query \"client.fritz.box\" will be redirected to the router's DNS server at 192.168.178.1 and client.lan.net to 192.170.1.2 and 192.170.1.3. The query \"client.example.com\" will be rewritten to \"client.fritz.box\" and also redirected to the resolver at 192.168.178.1.</p> <p>If not found and if <code>fallbackUpstream</code> was set to <code>true</code>, the original query \"blog.example.com\" will be sent upstream.</p> <p>All unqualified host names (e.g. \"test\") will be redirected to the DNS server at 168.168.0.1.</p> <p>One usecase for <code>fallbackUpstream</code> is when having split DNS for internal and external (internet facing) users, but not all subdomains are listed in the internal domain.</p>"},{"location":"configuration/#client-name-lookup","title":"Client name lookup","text":"<p>Blocky can try to resolve a user-friendly client name from the IP address or server URL (DoT and DoH). This is useful for defining of blocking groups, since IP address can change dynamically.</p>"},{"location":"configuration/#resolving-client-name-from-urlhost","title":"Resolving client name from URL/Host","text":"<p>If DoT or DoH is enabled, you can use a subdomain prefixed with <code>id-</code> to provide a client name (wildcard ssl certificate recommended).</p> <p>Example: domain <code>example.com</code></p> <p>DoT Host: <code>id-bob.example.com</code> -&gt; request's client name is <code>bob</code> DoH URL: <code>https://id-bob.example.com/dns-query</code> -&gt; request's client name is <code>bob</code></p> <p>For DoH you can also pass the client name as url parameter:</p> <p>DoH URL: <code>https://blocky.example.com/dns-query/alice</code> -&gt; request's client name is <code>alice</code></p>"},{"location":"configuration/#resolving-client-name-from-ip-address","title":"Resolving client name from IP address","text":"<p>Blocky uses rDNS to retrieve client's name. To use this feature, you can configure a DNS server for client lookup ( typically your router). You can also define client names manually per IP address.</p>"},{"location":"configuration/#single-name-order","title":"Single name order","text":"<p>Some routers return multiple names for the client (host name and user defined name). With parameter <code>clientLookup.singleNameOrder</code> you can specify, which of retrieved names should be used.</p>"},{"location":"configuration/#custom-client-name-mapping","title":"Custom client name mapping","text":"<p>You can also map a particular client name to one (or more) IP (ipv4/ipv6) addresses. Parameter <code>clientLookup.clients</code> contains a map of client name and multiple IP addresses.</p> <p>Example</p> <pre><code>clientLookup:\n  upstream: 192.168.178.1\n  singleNameOrder:\n    - 2\n    - 1\n  clients:\n    laptop:\n      - 192.168.178.29\n</code></pre> <p>Use <code>192.168.178.1</code> for rDNS lookup. Take second name if present, if not take first name. IP address <code>192.168.178.29</code> is mapped to <code>laptop</code> as client name.</p>"},{"location":"configuration/#blocking-and-allowlisting","title":"Blocking and allowlisting","text":"<p>Blocky can use lists of domains and IPs to block (e.g. advertisement, malware, trackers, adult sites). You can group several list sources together and define the blocking behavior per client. Blocking uses the DNS sinkhole approach. For each DNS query, the domain name from the request, IP address from the response, and any CNAME records will be checked to determine whether to block the query or not.</p> <p>To avoid over-blocking, you can use allowlists.</p>"},{"location":"configuration/#definition-allowdenylists","title":"Definition allow/denylists","text":"<p>Lists are defined in groups. This allows using different sets of lists for different clients.</p> <p>Each list in a group is a \"source\" and can be downloaded, read from a file, or inlined in the config. See Sources for details and configuring how those are loaded and reloaded/refreshed.</p> <p>The supported list formats are:</p> <ol> <li>the well-known Hosts format</li> <li>one domain per line (plain domain list)</li> <li>one wildcard per line</li> <li>one regex per line</li> </ol> <p>Example</p> <pre><code>blocking:\n  denylists:\n    ads:\n      - https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt\n      - https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts\n      - |\n        # inline definition using YAML literal block scalar style\n        # content is in plain domain list format\n        someadsdomain.com\n        anotheradsdomain.com\n        *.wildcard.example.com # blocks wildcard.example.com and all subdomains\n      - |\n        # inline definition with a regex\n        /^banners?[_.-]/\n    special:\n      - https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews/hosts\n  allowlists:\n    ads:\n      - allowlist.txt\n      - /path/to/file.txt\n      - |\n        # inline definition with YAML literal block scalar style\n        allowlistdomain.com\n</code></pre> <p>In this example you can see 2 groups: ads and special with one list. The ads group includes 2 inline lists.</p> <p>Warning</p> <p>If the same group has both allow/denylists, allowlists take precedence. Meaning if a domain is both blocked and allowed, it will be allowed. If a group has only allowlist entries, only domains from this list are allowed, and all others be blocked.</p> <p>Warning</p> <p>You must also define a client group mapping, otherwise the allow/denylist definitions will have no effect.</p>"},{"location":"configuration/#wildcard-support","title":"Wildcard support","text":"<p>You can use wildcards to block a domain and all its subdomains. Example: <code>*.example.com</code> will block <code>example.com</code> and <code>any.subdomains.example.com</code>.</p>"},{"location":"configuration/#regex-support","title":"Regex support","text":"<p>You can use regex to define patterns to block. A regex entry must start and end with the slash character (<code>/</code>). Some Examples:</p> <ul> <li><code>/baddomain/</code> will block <code>www.baddomain.com</code>, <code>baddomain.com</code>, but also <code>mybaddomain-sometext.com</code></li> <li><code>/^baddomain/</code> will block <code>baddomain.com</code>, but not <code>www.baddomain.com</code></li> <li><code>/^apple\\.(de|com)$/</code> will only block <code>apple.de</code> and <code>apple.com</code></li> </ul> <p>Warning</p> <p>Regexes use more a lot more memory and are much slower than wildcards, you should use them as a last resort.</p>"},{"location":"configuration/#client-groups","title":"Client groups","text":"<p>In this configuration section, you can define, which blocking group(s) should be used for which client in your network. Example: All clients should use the ads group, which blocks advertisement and kids devices should use the adult group, which blocky adult sites.</p> <p>Clients without an explicit group assignment will use the default group.</p> <p>You can use the client name (see Client name lookup), client's IP address, client's full-qualified domain name or a client subnet as CIDR notation.</p> <p>If full-qualified domain name is used (for example \"myclient.ddns.org\"), blocky will try to resolve the IP address (A and AAAA records) of this domain. If client's IP address matches with the result, the defined group will be used.</p> <p>Example</p> <pre><code>blocking:\n  clientGroupsBlock:\n  # default will be used, if no special definition for a client name exists\n    default:\n      - ads\n      - special\n    laptop*:\n      - ads\n    192.168.178.1/24:\n      - special\n    kid-laptop:\n      - ads\n      - adult\n</code></pre> <p>All queries from network clients, whose device name starts with <code>laptop</code>, will be filtered against the ads group's lists. All devices from the subnet <code>192.168.178.1/24</code> against the special group and <code>kid-laptop</code> against ads and adult. All other clients: ads and special.</p> <p>Tip</p> <p>You can use <code>*</code> as wildcard for the sequence of any character or <code>[0-9]</code> as number range</p>"},{"location":"configuration/#block-type","title":"Block type","text":"<p>You can configure, which response should be sent to the client, if a requested query is blocked (only for A and AAAA queries, NXDOMAIN for other types):</p> blockType Example Description zeroIP zeroIP This is the default block type. Server returns 0.0.0.0 (or :: for IPv6) as result for A and AAAA queries nxDomain nxDomain return NXDOMAIN as return code custom IPs 192.100.100.15, 2001:0db8:85a3:08d3:1319:8a2e:0370:7344 comma separated list of destination IP addresses. Should contain ipv4 and ipv6 to cover all query types. Useful with running web server on this address to display the \"blocked\" page. <p>Example</p> <pre><code>blocking:\n  blockType: nxDomain\n</code></pre>"},{"location":"configuration/#block-ttl","title":"Block TTL","text":"<p>TTL for answers to blocked domains can be set to customize the time (in duration format) clients ask for those domains again. Default Block TTL is 6 hours. This setting applies to all blocking modes and will affect how much time it could take for a client to be able to see the real IP address for a domain after receiving the blocked response.</p> <p>For <code>zeroIP</code> and custom IP modes: The TTL is applied to the returned A/AAAA records in the answer section.</p> <p>For <code>nxDomain</code> mode: The TTL is applied to the SOA record in the authority section. Per RFC 2308, Blocky includes an SOA record in NXDOMAIN responses to enable proper negative caching by stub resolvers. The blockTTL value is used for both the SOA's TTL and its MINIMUM field, ensuring clients cache the NXDOMAIN response for the configured duration.</p> <p>Example</p> <pre><code>blocking:\n  blockType: 192.100.100.15, 2001:0db8:85a3:08d3:1319:8a2e:0370:7344\n  blockTTL: 10s\n</code></pre>"},{"location":"configuration/#lists-loading","title":"Lists Loading","text":"<p>See Sources Loading.</p>"},{"location":"configuration/#caching","title":"Caching","text":"<p>Each DNS response has a TTL (Time-to-live) value. This value defines, how long is the record valid in seconds. The values are maintained by domain owners, server administrators etc. Blocky caches the answers from all resolved queries in own cache in order to avoid repeated requests. This reduces the DNS traffic and increases the network speed, since blocky can serve the result immediately from the cache.</p> <p>With following parameters you can tune the caching behavior:</p> <p>Warning</p> <p>Wrong values can significantly increase external DNS traffic or memory consumption.</p> Parameter Type Mandatory Default value Description caching.minTime duration format no 0 (use TTL) How long a response must be cached (min value). If &lt;=0, use response's TTL, if &gt;0 use this value, if TTL is smaller caching.maxTime duration format no 0 (use TTL) How long a response must be cached (max value). If &lt;0, do not cache responses. If 0, use TTL. If &gt; 0, use this value, if TTL is greater caching.maxItemsCount int no 0 (unlimited) Max number of cache entries (responses) to be kept in cache (soft limit). Default (0): unlimited. Useful on systems with limited amount of RAM. caching.prefetching bool no false if true, blocky will preload DNS results for often used queries (default: names queried more than 5 times in a 2 hour time window). Results in cache will be loaded again on their expire (TTL). This improves the response time for often used queries, but significantly increases external traffic. It is recommended to increase \"minTime\" to reduce the number of prefetch queries to external resolvers. caching.prefetchExpires duration format no 2h Prefetch track time window caching.prefetchThreshold int no 5 Name queries threshold for prefetch caching.prefetchMaxItemsCount int no 0 (unlimited) Max number of domains to be kept in cache for prefetching (soft limit). Default (0): unlimited. Useful on systems with limited amount of RAM. caching.cacheTimeNegative duration format no 30m Time how long negative results (NXDOMAIN response or empty result) are cached. A value of -1 will disable caching for negative results. caching.exclude Regex list no Exclusions rules as regex expressions of domains that won't be cached at all. Such as: /lan$/ or /^.*.host.com$/ <p>Example</p> <pre><code>caching:\n  minTime: 5m\n  maxTime: 30m\n  prefetching: true\n  exclude:\n    - /.*\\.lan$/\n    - /.*\\.local$/\n    - /.*\\.host\\.com\\.(jp|fr)$/\n</code></pre>"},{"location":"configuration/#redis","title":"Redis","text":"<p>Blocky can synchronize its cache and blocking state between multiple instances through redis. Synchronization is disabled if no address is configured.</p> Parameter Type Mandatory Default value Description redis.address string no Server address and port or master name if sentinel is used redis.username string no Username if necessary redis.password string no Password if necessary redis.database int no 0 Database redis.required bool no false Connection is required for blocky to start redis.connectionAttempts int no 3 Max connection attempts redis.connectionCooldown duration format no 1s Time between the connection attempts redis.sentinelUsername string no Sentinel username if necessary redis.sentinelPassword string no Sentinel password if necessary redis.sentinelAddresses string[] no Sentinel host list (Sentinel is activated if addresses are defined) <p>Example</p> <pre><code>redis:\n  address: redismaster\n  username: usrname\n  password: passwd\n  database: 2\n  required: true\n  connectionAttempts: 10\n  connectionCooldown: 3s\n  sentinelUsername: sentUsrname\n  sentinelPassword: sentPasswd\n  sentinelAddresses:\n    - redis-sentinel1:26379\n    - redis-sentinel2:26379\n    - redis-sentinel3:26379\n</code></pre>"},{"location":"configuration/#prometheus","title":"Prometheus","text":"<p>Blocky can expose various metrics for prometheus. To use the prometheus feature, the HTTP listener must be enabled ( see Basic Configuration).</p> Parameter Mandatory Default value Description prometheus.enable no false If true, enables prometheus metrics prometheus.path no /metrics URL path to the metrics endpoint <p>Example</p> <pre><code>prometheus:\n  enable: true\n  path: /metrics\n</code></pre>"},{"location":"configuration/#query-logging","title":"Query logging","text":"<p>You can enable the logging of DNS queries (question, answer, client, duration etc.) to a daily CSV file (can be opened in Excel or OpenOffice Calc) or MySQL/MariaDB database.</p> <p>Warning</p> <p>Query file/database contains sensitive information. Please ensure to inform users, if you log their queries.</p>"},{"location":"configuration/#query-log-types","title":"Query log types","text":"<p>You can select one of following query log types:</p> <ul> <li><code>mysql</code>: log each query in the external MySQL/MariaDB database</li> <li><code>postgresql</code>: log each query in the external PostgreSQL database</li> <li><code>timescale</code>: log each query in the external Timescale database</li> <li><code>csv</code>: log into CSV file (one per day)</li> <li><code>csv-client</code>: log into CSV file (one per day and per client)</li> <li><code>console</code>: log into console output</li> <li><code>none</code>: do not log any queries</li> </ul>"},{"location":"configuration/#query-log-fields","title":"Query log fields","text":"<p>You can choose which information from processed DNS request and response should be logged in the target system. You can define one or more of following fields:</p> <ul> <li><code>clientIP</code>: origin IP address from the request</li> <li><code>clientName</code>: resolved client name(s) from the origins request</li> <li><code>responseReason</code>: reason for the response (e.g. from which upstream resolver), response type and code</li> <li><code>responseAnswer</code>: returned DNS answer</li> <li><code>question</code>: DNS question from the request</li> <li><code>duration</code>: request processing time in milliseconds</li> </ul> <p>Hint</p> <p>If not defined, blocky will log all available information</p> <p>Configuration parameters:</p> Parameter Type Mandatory Default value Description queryLog.type enum (mysql, postgresql, timescale, csv, csv-client, console, none (see above)) no Type of logging target. Console if empty queryLog.target string no directory for writing the logs (for csv) or database url (for mysql, postgresql or timescale) queryLog.logRetentionDays int no 0 if &gt; 0, deletes log files/database entries which are older than ... days queryLog.creationAttempts int no 3 Max attempts to create specific query log writer queryLog.creationCooldown duration format no 2s Time between the creation attempts queryLog.fields list enum (clientIP, clientName, responseReason, responseAnswer, question, duration) no all which information should be logged queryLog.flushInterval duration format no 30s Interval to write data in bulk to the external database <p>Hint</p> <p>Please ensure, that the log directory is writable or database exists. If you use docker, please ensure, that the directory is properly mounted (e.g. volume)</p>"},{"location":"configuration/#database-urls","title":"Database URLs","text":"<p>To connect to a database, you must provide a URL like value for <code>target</code>. The exact format and supported parameters depends on the DB type. Parsing is handled not by Blocky, but third-party libraries, therefore the full documentation is external.</p> Database Full docs Format Example MySQL Go MySQL driver Data Source Name <code>[username[:password]@][protocol[(host[:port])]]/dbname[?param1=value1[&amp;paramN=valueN]]</code> <code>username:password@tcp(localhost:3306)/blocky_query_log?timeout=15s</code> PostgreSQL pgx.ParseConfig <code>postgres://[username[:password]@][host[:port]]/dbname[?param1=value1[&amp;paramN=valueN]]</code> <code>postgres://username@localhost:5432/blocky_query_log</code> Timescale See PostgreSQL above <p>Note</p> <p>For increased security, it is recommended to configure the password for a PostgreSQL/Timescale connection via the <code>PGPASSFILE</code> environment variable.</p>"},{"location":"configuration/#examples","title":"Examples","text":"<p>Example</p> <p>CSV format with limited logging information</p> <pre><code>```yaml\nqueryLog:\n  type: csv\n  target: /logs\n  logRetentionDays: 7\n  fields:\n  - clientIP\n  - duration\n  flushInterval: 30s\n```\n</code></pre> <p>Example</p> <p>MySQL Database</p> <pre><code>queryLog:\n  type: mysql\n  target: 'username:password@tcp(localhost:3306)/blocky_query_log?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&amp;timeout=15s'\n  logRetentionDays: 7\n</code></pre>"},{"location":"configuration/#hosts-file","title":"Hosts file","text":"<p>You can enable resolving of entries, located in local hosts file.</p> <p>Configuration parameters:</p> Parameter Type Mandatory Default value Description hostsFile.sources list of string no Host files (e.g. /etc/hosts on Linux) hostsFile.hostsTTL duration (no units is minutes) no 1h TTL hostsFile.filterLoopback bool no false Filter loopback addresses (127.0.0.0/8 and ::1) hostsFile.loading no See Sources Loading <p>Example</p> <pre><code>hostsFile:\n  sources:\n    - /etc/hosts\n  hostsTTL: 1h\n  loading:\n    refreshPeriod: 30m\n    strategy: fast\n</code></pre>"},{"location":"configuration/#deliver-ede-codes-as-edns0-option","title":"Deliver EDE codes as EDNS0 option","text":"<p>DNS responses can be extended with EDE codes according to RFC8914.</p> <p>Configuration parameters:</p> Parameter Type Mandatory Default value Description ede.enable bool no false If true, DNS responses are delivered with EDE codes <p>Example</p> <pre><code>ede:\n  enable: true\n</code></pre>"},{"location":"configuration/#edns-client-subnet-options","title":"EDNS Client Subnet options","text":"<p>EDNS Client Subnet (ECS) configuration parameters:</p> Parameter Type Mandatory Default value Description ecs.useAsClient bool no false Use ECS information if it is present with a netmask is 32 for IPv4 or 128 for IPv6 as CientIP ecs.forward bool no false Forward ECS option to upstream ecs.ipv4Mask int no 0 Add ECS option for IPv4 requests if mask is greater than zero (max value 32) ecs.ipv6Mask int no 0 Add ECS option for IPv6 requests if mask is greater than zero (max value 128) <p>Example</p> <pre><code>ecs:\n  ipv4Mask: 32\n  ipv6Mask: 128\n</code></pre>"},{"location":"configuration/#special-use-domain-names","title":"Special Use Domain Names","text":"<p>SUDN (Special Use Domain Names) are always enabled by default as they are required by various RFCs. Some RFCs have optional recommendations, which are configurable as described below. However, you can completely deactivate the blocking of SUDN by setting enable to false. Warning! You should only disable this if your upstream DNS server is local, as it shouldn't be disabled for remote upstreams.</p> <p>Configuration parameters:</p> Parameter Type Mandatory Default value Description specialUseDomains.rfc6762-appendixG bool no true Block TLDs listed in RFC 6762 Appendix G enable bool no true completely disable or enable SUDN blocking <p>Example</p> <pre><code>specialUseDomains:\n  rfc6762-appendixG: true\n</code></pre> <p>Example</p> <pre><code>specialUseDomains:\n  enable: false\n</code></pre>"},{"location":"configuration/#dnssec-validation","title":"DNSSEC validation","text":"<p>DNSSEC (Domain Name System Security Extensions) provides cryptographic authentication of DNS data to protect against cache poisoning, man-in-the-middle attacks, and DNS spoofing. When enabled, Blocky validates DNSSEC signatures on DNS responses and ensures the chain of trust from the root zone to the queried domain.</p>"},{"location":"configuration/#overview","title":"Overview","text":"<p>When DNSSEC validation is enabled, Blocky will:</p> <ul> <li>Set the DNSSEC OK (DO) bit on all upstream queries to request DNSSEC records</li> <li>Validate cryptographic signatures (RRSIG records) in DNS responses</li> <li>Verify the chain of trust from root to the queried domain using DNSKEY and DS records</li> <li>Validate authenticated denial of existence using NSEC/NSEC3 records for NXDOMAIN and NODATA responses</li> <li>Validate wildcard expansions according to RFC 4035 \u00a75.3.4</li> <li>Return SERVFAIL for responses with invalid DNSSEC signatures (Bogus)</li> <li>Set the Authenticated Data (AD) flag only after successful validation</li> <li>Add Extended DNS Error (EDE) codes per RFC 8914 when validation fails</li> </ul>"},{"location":"configuration/#rfc-compliance","title":"RFC Compliance","text":"<p>Blocky's DNSSEC implementation complies with the following RFCs:</p> <ul> <li>RFC 4033/4034/4035 (DNSSEC core specifications): Fully implemented</li> <li>RFC 5155 (NSEC3): Implemented with configurable iteration limits</li> <li>RFC 6840 (DNSSEC clarifications): Implemented including algorithm downgrade protection</li> <li>RFC 8624 (Algorithm implementation requirements): Supports recommended algorithms</li> <li>RFC 8914 (Extended DNS Errors): Provides detailed error information</li> </ul>"},{"location":"configuration/#security-benefits","title":"Security Benefits","text":"<p>DNSSEC validation protects against:</p> <ul> <li>Cache poisoning attacks: Prevents attackers from injecting false DNS records into the cache</li> <li>Man-in-the-middle attacks: Ensures DNS responses haven't been tampered with in transit</li> <li>DNS spoofing: Verifies that DNS responses come from authoritative sources</li> <li>Forged denial-of-existence: Validates that NXDOMAIN responses are authentic</li> </ul>"},{"location":"configuration/#configuration-parameters","title":"Configuration Parameters","text":"Parameter Type Mandatory Default value Description dnssec.validate bool no false Enable DNSSEC validation dnssec.maxChainDepth uint no 10 Maximum domain label depth for chain of trust validation (DoS protection) dnssec.cacheExpirationHours uint no 1 How long to cache validation results in hours dnssec.maxUpstreamQueries uint no 30 Maximum upstream DNS queries per validation request (DoS protection) dnssec.maxNSEC3Iterations uint no 150 Maximum NSEC3 hash iterations allowed (DoS protection, per RFC 5155 \u00a710.3) dnssec.clockSkewToleranceSec uint no 3600 Clock skew tolerance in seconds for signature validation (per RFC 6781 \u00a74.1.2) dnssec.trustAnchors string array no [] Custom trust anchors (DNSKEY or DS records). Empty array uses built-in root trust anchors"},{"location":"configuration/#dos-protection","title":"DoS Protection","text":"<p>DNSSEC validation can be computationally expensive and requires additional DNS queries. Blocky includes several protections against DoS attacks:</p> <ul> <li>maxChainDepth: Limits validation depth for deeply nested domains (e.g., prevents validation of <code>a.b.c.d.e.f.g.h.i.j.example.com</code>)</li> <li>maxUpstreamQueries: Limits the number of upstream queries (DNSKEY/DS lookups) per validation to prevent query amplification</li> <li>maxNSEC3Iterations: Limits NSEC3 hash iterations to prevent CPU exhaustion attacks</li> <li>Validation caching: Caches validation results to avoid repeated expensive validations</li> </ul>"},{"location":"configuration/#clock-skew-tolerance","title":"Clock Skew Tolerance","text":"<p>DNSSEC signatures have inception and expiration timestamps. Blocky validates that the current time falls within this validity window. However, in real-world deployments, system clocks may not be perfectly synchronized, which can cause valid signatures to be rejected.</p> <p>The <code>clockSkewToleranceSec</code> parameter (default: 3600 seconds = 1 hour) allows validation to succeed even if the system clock is off by the specified amount. This matches the behavior of industry-standard validators like Unbound and BIND.</p> <p>Common scenarios where clock skew tolerance is important:</p> <ul> <li>Virtual machines: Clock drift after suspend/resume or snapshot restore operations</li> <li>Containers: Clock synchronization issues with the host system</li> <li>IoT/embedded devices: Systems without NTP or with battery-backed RTCs that lose time</li> <li>Systems during NTP sync: Time adjustment in progress when DNSSEC validation is needed</li> <li>Raspberry Pi and similar SBCs: Devices that lose time on power loss</li> </ul> <p>Recommended values:</p> <ul> <li>300 seconds (5 minutes): Conservative setting, handles typical NTP drift</li> <li>3600 seconds (1 hour): Default, handles timezone/DST issues and matches Unbound/BIND</li> <li>7200 seconds (2 hours): Lenient setting for systems with significant clock problems</li> </ul> <p>Security vs. Robustness Tradeoff</p> <p>Larger clock skew tolerance values increase the risk of accepting signatures that are actually expired or not yet valid. Smaller values increase the risk of false negatives from clock drift. For production deployments, ensure NTP or systemd-timesyncd is properly configured and use the default 1-hour tolerance.</p>"},{"location":"configuration/#validation-results","title":"Validation Results","text":"<p>Blocky classifies DNSSEC validation results into four categories:</p> Result Description Response Handling Secure Valid DNSSEC signatures and complete chain of trust AD flag set, response returned Insecure Domain is not signed with DNSSEC (no RRSIG records) AD flag cleared, response returned Bogus Invalid DNSSEC signatures or broken chain of trust SERVFAIL returned with EDE code Indeterminate Validation could not be completed (e.g., network errors, budget exceeded) AD flag cleared, response returned"},{"location":"configuration/#trust-anchors","title":"Trust Anchors","text":"<p>By default, Blocky uses the latest IANA root trust anchors (KSK-2017 and KSK-2024) for DNSSEC validation. These are the same trust anchors used by major DNS resolvers and are embedded in the Blocky binary.</p>"},{"location":"configuration/#custom-trust-anchors","title":"Custom Trust Anchors","text":"<p>You can override the default trust anchors for:</p> <ul> <li>Testing DNSSEC in lab environments</li> <li>Validating private/internal DNSSEC-signed zones</li> <li>Using specific trust anchors for organizational requirements</li> </ul> <p>Trust anchors can be specified in two formats:</p> <ol> <li>DNSKEY format: Full DNSKEY record in zone file format</li> <li>DS format: DS record pointing to a DNSKEY in the child zone</li> </ol> <p>Warning</p> <p>Specifying custom trust anchors replaces the default root trust anchors. If you need to validate both public domains and private zones, you must include both the root trust anchors and your custom anchors.</p>"},{"location":"configuration/#supported-algorithms","title":"Supported Algorithms","text":"<p>Blocky supports the following DNSSEC algorithms per RFC 8624:</p> Algorithm ID Status Security Level RSASHA1 5 Deprecated (still supported) Weak RSASHA256 8 Recommended Moderate RSASHA512 10 Recommended Moderate ECDSAP256SHA256 13 Recommended Strong ECDSAP384SHA384 14 Recommended Strong ED25519 15 Recommended Very Strong ED448 16 Recommended Strongest <p>Blocky automatically selects the strongest available algorithm when multiple signatures are present, providing protection against algorithm downgrade attacks per RFC 6840 \u00a75.11.</p>"},{"location":"configuration/#performance-considerations","title":"Performance Considerations","text":"<p>DNSSEC validation adds overhead to DNS resolution:</p> <ul> <li>Additional queries: Each validation may require 2-4 additional queries for DNSKEY and DS records</li> <li>Cryptographic operations: Signature verification requires CPU time</li> <li>Caching helps significantly: The validation cache reduces overhead for frequently queried domains</li> </ul> <p>Recommendations:</p> <ul> <li>Start with <code>cacheExpirationHours: 1</code> and increase if validation overhead is acceptable</li> <li>Monitor upstream query count with the <code>maxUpstreamQueries</code> metric</li> <li>Use <code>prefetching</code> in the caching resolver to pre-validate popular domains</li> <li>Consider disabling for high-volume recursive resolvers if performance is critical</li> </ul>"},{"location":"configuration/#examples_1","title":"Examples","text":"<p>Basic DNSSEC validation</p> <pre><code>dnssec:\n  validate: true\n</code></pre> <p>This enables DNSSEC validation with all default settings. Blocky will validate all DNSSEC-signed domains using the built-in root trust anchors.</p> <p>DNSSEC validation with custom DoS protection</p> <pre><code>dnssec:\n  validate: true\n  maxChainDepth: 15\n  maxUpstreamQueries: 50\n  maxNSEC3Iterations: 100\n  cacheExpirationHours: 2\n</code></pre> <p>This configuration increases the allowed chain depth and upstream queries for complex delegation scenarios, while reducing NSEC3 iterations for better DoS protection and doubling the cache duration.</p> <p>DNSSEC validation with clock skew tolerance for embedded systems</p> <pre><code>dnssec:\n  validate: true\n  clockSkewToleranceSec: 7200  # 2 hours tolerance for systems with clock drift\n</code></pre> <p>This configuration is suitable for embedded devices, Raspberry Pi, or systems without reliable NTP. The 2-hour tolerance allows validation to succeed even with significant clock drift, while still providing DNSSEC security.</p> <p>DNSSEC validation with custom trust anchor for private zone</p> <pre><code>dnssec:\n  validate: true\n  trustAnchors:\n    # Root KSK-2024 (required for public domains)\n    - \". 172800 IN DNSKEY 257 3 8 AwEAAaz/tAm8yTn4Mfeh5eyI96WSVexTBAvkMgJzkKTOiW1vkIbzxeF3...\"\n    # Custom DNSKEY for internal zone\n    - \"corp.internal. 86400 IN DNSKEY 257 3 13 mdsswUyr3DPW132mOi8V9xESWE8jTo0dxCjjnopKl+GqJxpVXckHAeF...\"\n</code></pre> <p>This configuration validates both public internet domains (using the root trust anchor) and a private <code>corp.internal</code> zone using a custom trust anchor.</p> <p>Testing DNSSEC validation</p> <pre><code>dnssec:\n  validate: true\nlog:\n  level: debug\n</code></pre> <p>Enable debug logging to see detailed DNSSEC validation information for troubleshooting.</p>"},{"location":"configuration/#monitoring","title":"Monitoring","text":"<p>Blocky exposes Prometheus metrics for DNSSEC validation:</p> <ul> <li><code>blocky_dnssec_validation_total{result=\"secure|insecure|bogus|indeterminate\"}</code>: Total validations by result</li> <li><code>blocky_dnssec_cache_hits_total</code>: Number of validation cache hits</li> <li><code>blocky_dnssec_validation_duration_seconds{result=\"...\"}</code>: Validation duration histogram</li> </ul>"},{"location":"configuration/#troubleshooting","title":"Troubleshooting","text":"<p>Problem: All DNSSEC-signed domains return SERVFAIL</p> <ul> <li>Check that your upstream DNS servers support DNSSEC and return DNSSEC records</li> <li>Verify the DO bit is being set on upstream queries (check logs with <code>log.level: debug</code>)</li> <li>Ensure your upstream servers are not stripping DNSSEC records</li> </ul> <p>Problem: Specific domain fails DNSSEC validation</p> <ul> <li>Check if the domain's DNSSEC is properly configured using online validators like DNSViz or Verisign DNSSEC Debugger</li> <li>Enable debug logging to see detailed validation failure reasons</li> <li>Check for expired RRSIG records or missing DNSKEY records</li> </ul> <p>Problem: High CPU usage after enabling DNSSEC</p> <ul> <li>Increase <code>cacheExpirationHours</code> to reduce validation frequency</li> <li>Lower <code>maxNSEC3Iterations</code> if validating many NSEC3-signed zones</li> <li>Consider disabling DNSSEC validation for internal-only resolvers</li> </ul> <p>Problem: Validation fails with \"budget exhausted\"</p> <ul> <li>Increase <code>maxUpstreamQueries</code> for domains with complex delegation chains</li> <li>Check if upstream servers are slow to respond (may require multiple retries)</li> <li>Increase <code>maxChainDepth</code> for deeply nested subdomains</li> </ul> <p>Problem: Signatures rejected as \"expired\" or \"not yet valid\" despite being valid</p> <ul> <li>Check your system clock is synchronized with NTP (<code>timedatectl status</code> on Linux)</li> <li>Increase <code>clockSkewToleranceSec</code> if your system has known clock drift issues (VMs, containers, embedded devices)</li> <li>Verify RRSIG inception/expiration times are reasonable using online validators</li> <li>For systems without NTP, consider using a larger tolerance (e.g., 7200 seconds = 2 hours)</li> </ul>"},{"location":"configuration/#dns64","title":"DNS64","text":"<p>DNS64 (RFC 6147) enables IPv6-only clients to access IPv4-only services by synthesizing AAAA (IPv6) records from A (IPv4) records. This technology is critical for IPv6-only networks such as cellular networks, IoT deployments, modern datacenters, and enterprise networks transitioning to IPv6.</p>"},{"location":"configuration/#overview_1","title":"Overview","text":"<p>When DNS64 is enabled, Blocky will:</p> <ul> <li>Intercept AAAA queries and check if native IPv6 records exist</li> <li>If no native AAAA records are found, query for A records</li> <li>Synthesize AAAA records by embedding IPv4 addresses into configured IPv6 prefixes</li> <li>Return synthesized AAAA records with proper TTL and DNSSEC handling</li> <li>Preserve CNAME/DNAME chains in synthesized responses</li> <li>Skip synthesis if AAAA records already exist (unless they're in the exclusion set)</li> </ul> <p>NAT64 Required</p> <p>DNS64 requires a NAT64 gateway in your network. DNS64 alone won't enable IPv6-only clients to reach IPv4 destinations. The DNS64 prefix must match your NAT64 gateway's configuration.</p>"},{"location":"configuration/#rfc-compliance_1","title":"RFC Compliance","text":"<p>Blocky's DNS64 implementation complies with:</p> <ul> <li>RFC 6147 (DNS64 specification): Non-validating mode implementation</li> <li>RFC 6052 (IPv4-to-IPv6 address embedding): All six prefix lengths supported (/32, /40, /48, /56, /64, /96)</li> <li>RFC 8914 (Extended DNS Errors): Synthesized responses include EDE code 4 (Forged Answer)</li> </ul>"},{"location":"configuration/#configuration-parameters_1","title":"Configuration Parameters","text":"Parameter Type Mandatory Default value Description dns64.enable bool no false Enable DNS64 synthesis dns64.prefixes array of CIDR no [64:ff9b::/96] IPv6 prefixes for synthesis. Valid lengths: /32, /40, /48, /56, /64, /96 (per RFC 6052) dns64.exclusionSet array of CIDR no [::ffff:0:0/96, ::1/128, fe80::/10] + prefixes Custom exclusion set. Advanced use only - overrides default exclusion behavior"},{"location":"configuration/#dns64-prefixes","title":"DNS64 Prefixes","text":"<p>DNS64 uses IPv6 prefixes to embed IPv4 addresses. RFC 6052 defines six valid prefix lengths, each with different bit layouts:</p> Prefix Length Bits Used IPv4 Position Example Prefix Example Synthesis /96 96 bits 96-127 <code>64:ff9b::/96</code> <code>192.0.2.1</code> \u2192 <code>64:ff9b::192.0.2.1</code> /64 64 bits 72-103 <code>2001:db8::/64</code> <code>192.0.2.1</code> \u2192 <code>2001:db8::c000:201</code> /56 56 bits 56-63, 72-95 <code>2001:db8::/56</code> <code>192.0.2.1</code> \u2192 <code>2001:db8:c0:0:201::</code> /48 48 bits 48-63, 72-87 <code>2001:db8::/48</code> <code>192.0.2.1</code> \u2192 <code>2001:db8:0:c000:2:100::</code> /40 40 bits 40-63, 72-79 <code>2001:db8::/40</code> <code>192.0.2.1</code> \u2192 <code>2001:db8:c0:2:1::</code> /32 32 bits 32-63 <code>2001:db8::/32</code> <code>192.0.2.1</code> \u2192 <code>2001:db8:c000:201::</code> <p>Well-known prefix (default): <code>64:ff9b::/96</code> is the RFC 6052 well-known prefix, recommended for most deployments.</p> <p>Multiple prefixes: You can configure multiple prefixes for load balancing across multiple NAT64 gateways. DNS64 will synthesize one AAAA record per prefix per A record.</p> <p>Prefix Overlap Validation</p> <p>Blocky validates that configured prefixes do not overlap. Overlapping prefixes will cause startup failure.</p>"},{"location":"configuration/#exclusion-set","title":"Exclusion Set","text":"<p>DNS64 will not synthesize AAAA records if the response already contains AAAA records that are not in the exclusion set. This prevents synthesizing for domains that already have native IPv6 support.</p>"},{"location":"configuration/#default-exclusion-set-recommended","title":"Default Exclusion Set (Recommended)","text":"<p>If <code>dns64.exclusionSet</code> is not configured, Blocky uses the default exclusion set:</p> <ul> <li>IPv4-mapped IPv6 addresses (<code>::ffff:0:0/96</code>) - RFC 6147 requirement</li> <li>Loopback address (<code>::1/128</code>) - RFC 6147 recommendation</li> <li>Link-local addresses (<code>fe80::/10</code>) - RFC 6147 recommendation</li> <li>Unspecified address (<code>::/128</code>) - Special case</li> <li>Configured DNS64 prefixes - Automatically added to prevent synthesis loops</li> </ul> <p>Example: If a domain returns AAAA record <code>2001:db8::1</code> (not in exclusion set), DNS64 will not synthesize. If a domain returns only <code>::1</code> (in exclusion set), DNS64 will synthesize from A records.</p>"},{"location":"configuration/#custom-exclusion-set-advanced","title":"Custom Exclusion Set (Advanced)","text":"<p>Advanced Configuration</p> <p>Configuring a custom exclusion set is an advanced feature and should only be used if you understand DNS64 synthesis behavior. Most users should use the default exclusion set.</p> <p>You can configure a custom exclusion set using the <code>dns64.exclusionSet</code> parameter:</p> <p>Example</p> <pre><code>dns64:\n  enable: true\n  prefixes:\n    - 64:ff9b::/96\n  exclusionSet:\n    - ::ffff:0:0/96  # IPv4-mapped (REQUIRED by RFC)\n    - ::1/128        # Loopback (recommended)\n    - fe80::/10      # Link-local (recommended)\n    - 64:ff9b::/96   # Your configured prefix (recommended to prevent loops)\n    - 2001:db8::/32  # Custom exclusion range\n</code></pre> <p>Important: No Automatic Prefix Addition</p> <p>When using a custom exclusion set, configured DNS64 prefixes are NOT automatically added. You must explicitly include your configured prefixes in the exclusion set to prevent synthesis loops.</p> <p>Bad configuration (will cause synthesis loops): <pre><code>dns64:\n  prefixes:\n    - 64:ff9b::/96\n  exclusionSet:\n    - ::ffff:0:0/96  # Missing configured prefix!\n</code></pre></p> <p>Good configuration: <pre><code>dns64:\n  prefixes:\n    - 64:ff9b::/96\n  exclusionSet:\n    - ::ffff:0:0/96\n    - 64:ff9b::/96   # Includes configured prefix\n</code></pre></p>"},{"location":"configuration/#dnssec-handling-non-validating-mode","title":"DNSSEC Handling (Non-Validating Mode)","text":"<p>DNS64 operates in non-validating mode and handles DNSSEC as follows:</p> <ul> <li>DO bit: Copied from original AAAA query to A query (preserves client's DNSSEC request)</li> <li>CD bit: Copied from original AAAA query to A query (preserves checking-disabled flag)</li> <li>AD bit: Always cleared in synthesized responses (synthesis breaks authentication)</li> <li>Extended DNS Error: Synthesized responses include EDE code 4 (Forged Answer)</li> </ul> <p>Future: DNSSEC-Aware DNS64</p> <p>Future enhancement may implement RFC 6147 Section 3 (DNSSEC-aware operation), where DNS64 can validate DNSSEC signatures and set the AD bit appropriately for synthesized responses. The current non-validating mode is suitable for most deployments.</p>"},{"location":"configuration/#performance-considerations_1","title":"Performance Considerations","text":"<p>DNS64 adds overhead to DNS resolution:</p> <ul> <li>Additional A query: Every AAAA query that requires synthesis triggers an additional A query</li> <li>Caching is critical: Enable caching to minimize upstream query load</li> <li>Cache hit rate: With caching, most AAAA queries hit the cache and avoid synthesis overhead</li> </ul> <p>Enable Caching for DNS64</p> <p>DNS64 without caching will double upstream query load (one AAAA + one A per query). Blocky will log a warning if DNS64 is enabled without caching.</p>"},{"location":"configuration/#ssl-certificate-configuration-doh-tls-listener","title":"SSL certificate configuration (DoH / TLS listener)","text":"<p>See Wiki - Configuration of HTTPS for detailed information, how to create and configure SSL certificates.</p> <p>DoH url: <code>https://host:port/dns-query</code></p>"},{"location":"configuration/#sources","title":"Sources","text":"<p>Sources are a concept shared by the blocking and hosts file resolvers. They represent where to load the files for each resolver.</p> <p>The supported source types are:</p> <ul> <li>HTTP(S) URL (any source starting with <code>http</code>)</li> <li>inline configuration (any source containing a newline)</li> <li>local file path (any source not matching the above rules)</li> </ul> <p>Note</p> <p>The format/content of the sources depends on the context: lists and hosts files have different, but overlapping, supported formats.</p> <p>Example</p> <pre><code>- https://example.com/a/source # blocky will download and parse the file\n- /a/file/path # blocky will read the local file\n- | # blocky will parse the content of this multi-line string\n  # inline configuration\n</code></pre>"},{"location":"configuration/#sources-loading","title":"Sources Loading","text":"<p>This sections covers <code>loading</code> configuration that applies to both the blocking and hosts file resolvers. These settings apply only to the resolver under which they are nested.</p> <p>Example</p> <pre><code>blocking:\n  loading:\n    # only applies to allow/denylists\n\nhostsFile:\n  loading:\n    # only applies to hostsFile sources\n</code></pre>"},{"location":"configuration/#refresh-reload","title":"Refresh / Reload","text":"<p>To keep source contents up-to-date, blocky can periodically refresh and reparse them. Default period is 4 hours. You can configure this by setting the <code>refreshPeriod</code> parameter to a value in duration format. A value of zero or less will disable this feature.</p> <p>Example</p> <pre><code>loading:\n  refreshPeriod: 1h\n</code></pre> <p>Refresh every hour.</p>"},{"location":"configuration/#downloads","title":"Downloads","text":"<p>Configures how HTTP(S) sources are downloaded:</p> Parameter Type Mandatory Default value Description timeout duration no 5s Download attempt timeout writeTimeout duration no 20s File write attempt timeout readTimeout duration no 20s Download request read timeout readHeaderTimeout duration no 20s Download request header read timeout attempts int no 3 How many download attempts should be performed cooldown duration no 500ms Time between the download attempts <p>Example</p> <pre><code>loading:\n  downloads:\n    timeout: 4m\n    attempts: 5\n    cooldown: 10s\n</code></pre>"},{"location":"configuration/#strategy","title":"Strategy","text":"<p>See Init Strategy. In this context, \"init\" is loading and parsing each source, and an error is a single source failing to load/parse.</p> <p>Example</p> <pre><code>loading:\n  strategy: failOnError\n</code></pre>"},{"location":"configuration/#max-errors-per-source","title":"Max Errors per Source","text":"<p>Number of errors allowed when parsing a source before it is considered invalid and parsing stops. A value of -1 disables the limit.</p> <p>Example</p> <pre><code>loading:\n  maxErrorsPerSource: 10\n</code></pre>"},{"location":"configuration/#concurrency","title":"Concurrency","text":"<p>Blocky downloads and processes sources concurrently. This allows limiting how many can be processed in the same time. Larger values can reduce the overall list refresh time at the cost of using more RAM. Please consider reducing this value on systems with limited memory. Default value is 4.</p> <p>Example</p> <pre><code>loading:\n  concurrency: 10\n</code></pre> <p>Note</p> <p>As with other settings under <code>loading</code>, the limit applies to the blocking and hosts file resolvers separately. The total number of concurrent sources concurrently processed can reach the sum of both values. For example if blocking has a limit set to 8 and hosts file's is 4, there could be up to 12 concurrent jobs.</p>"},{"location":"installation/","title":"Installation","text":"<p>You can choose one of the following installation options:</p> <ul> <li>Run as standalone binary</li> <li>Run as docker container</li> </ul>"},{"location":"installation/#prepare-your-configuration","title":"Prepare your configuration","text":"<p>Blocky supports single or multiple YAML files as configuration. Create new <code>config.yml</code> with your configuration (see Configuration for more details and all configuration options).</p> <p>Simple configuration file, which enables only basic features:</p> <pre><code>upstreams:\n  groups:\n    default:\n      - 46.182.19.48\n      - 80.241.218.68\n      - tcp-tls:fdns1.dismail.de:853\n      - https://dns.digitale-gesellschaft.ch/dns-query\nblocking:\n  denylists:\n    ads:\n      - https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts\n  clientGroupsBlock:\n    default:\n      - ads\nports:\n  dns: 53\n  http: 4000\n</code></pre>"},{"location":"installation/#run-as-standalone-binary","title":"Run as standalone binary","text":"<p>Download the binary file from GitHub for your architecture and run <code>./blocky --config config.yml</code>.</p> <p>Warning</p> <p>Please be aware, if you want to use port 53 or 953 on Linux you should add <code>CAP_NET_BIND_SERVICE</code> capability to the binary with <code>setcap 'cap_net_bind_service=+ep' ./blocky</code>, or run as root (not recommended).</p>"},{"location":"installation/#run-with-docker","title":"Run with docker","text":""},{"location":"installation/#alternative-registry","title":"Alternative registry","text":"<p>Blocky docker images are deployed to DockerHub (<code>spx01/blocky</code>) and GitHub Container Registry (<code>ghcr.io/0xerr0r/blocky</code>).</p>"},{"location":"installation/#parameters","title":"Parameters","text":"<p>You can define the location of the config file in the container with environment variable <code>BLOCKY_CONFIG_FILE</code>. Default value is <code>/app/config.yml</code>.</p>"},{"location":"installation/#docker-from-command-line","title":"Docker from command line","text":"<p>Execute following command from the command line:</p> <pre><code>docker run --name blocky -v /path/to/config.yml:/app/config.yml -p 4000:4000 -p 53:53/udp spx01/blocky\n</code></pre>"},{"location":"installation/#run-with-docker-compose","title":"Run with docker-compose","text":"<p>Create following <code>docker-compose.yml</code> file</p> <pre><code>version: \"2.1\"\nservices:\n  blocky:\n    image: spx01/blocky\n    container_name: blocky\n    restart: unless-stopped\n    # Optional the instance hostname for logging purpose\n    hostname: blocky-hostname\n    ports:\n      - \"53:53/tcp\"\n      - \"53:53/udp\"\n      - \"4000:4000/tcp\"\n    environment:\n      - TZ=Europe/Berlin # Optional to synchronize the log timestamp with host\n    volumes:\n      # Optional to synchronize the log timestamp with host\n      - /etc/localtime:/etc/localtime:ro\n      # config file\n      - ./config.yml:/app/config.yml:ro\n</code></pre> <p>and start docker container with</p> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"installation/#advanced-setup","title":"Advanced setup","text":"<p>Following example shows, how to run blocky in a docker container and store query logs on a SAMBA share. Local black and allowlists directories are mounted as volume. You can create own black or allowlists in these directories and define the path like '/app/allowlists/allowlist.txt' in the config file.</p> <p>Example</p> <pre><code>version: \"2.1\"\nservices:\n  blocky:\n    image: spx01/blocky\n    container_name: blocky\n    restart: unless-stopped\n    ports:\n      - \"53:53/tcp\"\n      - \"53:53/udp\"\n      - \"4000:4000/tcp\" # Prometheus stats (if enabled)\n    environment:\n      - TZ=Europe/Berlin\n    volumes:\n      # config file\n      - ./config.yml:/app/config.yml:ro\n      # write query logs in this volume\n      - queryLogs:/logs\n      # put your custom allow/denylists in these directories\n      - ./denylists:/app/denylists/\n      - ./allowlists:/app/allowlists/\n\nvolumes:\n  queryLogs:\n    driver: local\n    driver_opts:\n      type: cifs\n      o: username=USER,password=PASSWORD,rw\n      device: //NAS_HOSTNAME/blocky\n</code></pre>"},{"location":"installation/#multiple-configuration-files","title":"Multiple configuration files","text":"<p>For complex setups, splitting the configuration between multiple YAML files might be desired. In this case, folder containing YAML files is passed on startup, Blocky will join all the files.</p> <pre><code>./blocky --config ./config/\n</code></pre> <p>Warning</p> <p>Blocky simply joins the multiple YAML files. If an option (e.g. <code>upstream</code>) is present in multiple files, the configuration will not load and start will fail.</p>"},{"location":"installation/#other-installation-types","title":"Other installation types","text":"<p>Warning</p> <p>These projects are not associated with Blocky devs and are listed here for convenience.</p>"},{"location":"installation/#arch-linux-via-aur","title":"Arch Linux via AUR","text":"<p>See https://aur.archlinux.org/packages/blocky/</p>"},{"location":"installation/#alpine-linux","title":"Alpine Linux","text":"<p>See https://pkgs.alpinelinux.org/packages?name=blocky&amp;branch=edge&amp;repo=&amp;arch=</p>"},{"location":"installation/#centosdebianfedora-install-script","title":"CentOS/Debian/Fedora install script","text":"<p>See https://github.com/m0zgen/blocky-installer</p>"},{"location":"installation/#freebsd","title":"FreeBSD","text":"<p>See https://www.freebsd.org/cgi/ports.cgi?query=blocky&amp;stype=all</p>"},{"location":"installation/#gentoo","title":"Gentoo","text":"<p>See the Gentoo Wiki to enable the GURU repository, then run <code>emerge net-dns/blocky</code>.</p>"},{"location":"installation/#nixos","title":"NixOS","text":"<p>Add <code>pkgs.blocky</code> as a module:</p> <pre><code>services.blocky = {\n  enable = true;\n\n  settings = {\n    # anything from config.yml\n  };\n};\n</code></pre>"},{"location":"installation/#macos-via-homebrew","title":"macOS via Homebrew","text":"<p>See https://formulae.brew.sh/formula/blocky</p>"},{"location":"installation/#truenas-scale-via-truecharts","title":"TrueNAS SCALE via TrueCharts","text":"<p>See https://truecharts.org/charts/enterprise/blocky/ (TrueCharts is not an official TrueNAS project)</p>"},{"location":"installation/#companion-projects","title":"Companion projects","text":"<p>Warning</p> <p>These projects are not associated with Blocky devs and are listed here for convenience.</p>"},{"location":"installation/#lists-updater","title":"Lists updater","text":"<p>Blocky lists updater updates list related configuration without restarting blocky DNS.</p>"},{"location":"installation/#web-uis","title":"Web UIs","text":"<ul> <li> <p>Blocky Frontend provides a Web UI to control blocky. See linked project for installation instructions.</p> </li> <li> <p>BlockyUI provides a fully featured and modern Web UI for managing your Blocky DNS server.</p> </li> </ul>"},{"location":"interfaces/","title":"Interfaces","text":""},{"location":"interfaces/#rest-api","title":"REST API","text":"OpenAPI specification <pre><code>openapi: 3.1.1\ninfo:\n  title: blocky API\n  description: &gt;-\n    # Blocky\n\n    Blocky is a DNS proxy and ad-blocker for the local network written in Go with following features:\n\n    ## Features\n\n    - **Blocking** - Blocking of DNS queries with external lists (Ad-block, malware) and allowlisting\n\n      - Definition of allow/denylists per client group (Kids, Smart home devices, etc.)\n      - Periodical reload of external allow/denylists\n      - Regex support\n      - Blocking of request domain, response CNAME (deep CNAME inspection) and response IP addresses (against IP lists)\n\n    - **Advanced DNS configuration** - not just an ad-blocker\n\n      - Custom DNS resolution for certain domain names\n      - Conditional forwarding to external DNS server\n      - Upstream resolvers can be defined per client group\n\n    - **Performance** - Improves speed and performance in your network\n\n      - Customizable caching of DNS answers for queries -&gt; improves DNS resolution speed and reduces amount of external DNS\n        queries\n      - Prefetching and caching of often used queries\n      - Using multiple external resolver simultaneously\n      - Low memory footprint\n\n    - **Various Protocols** - Supports modern DNS protocols\n\n      - DNS over UDP and TCP\n      - DNS over HTTPS (aka DoH)\n      - DNS over TLS (aka DoT)\n\n    - **Security and Privacy** - Secure communication\n\n      - Supports modern DNS extensions: DNSSEC, eDNS, ...\n      - Free configurable blocking lists - no hidden filtering etc.\n      - Provides DoH Endpoint\n      - Uses random upstream resolvers from the configuration - increases your privacy through the distribution of your DNS\n        traffic over multiple provider\n      - Blocky does **NOT** collect any user data, telemetry, statistics etc.\n\n    - **Integration** - various integration\n\n      - [Prometheus](https://prometheus.io/) metrics\n      - Prepared [Grafana](https://grafana.com/) dashboards (Prometheus and database)\n      - Logging of DNS queries per day / per client in CSV format or MySQL/MariaDB/PostgreSQL/Timescale database - easy to\n        analyze\n      - Various REST API endpoints\n      - CLI tool\n\n    - **Simple configuration** - single or multiple configuration files in YAML format\n\n      - Simple to maintain\n      - Simple to backup\n\n    - **Simple installation/configuration** - blocky was designed for simple installation\n\n      - Stateless (no database, no temporary files)\n      - Docker image with Multi-arch support\n      - Single binary\n      - Supports x86-64 and ARM architectures -&gt; runs fine on Raspberry PI\n      - Community supported Helm chart for k8s deployment\n\n    ## Quick start\n\n    You can jump to [Installation](https://0xerr0r.github.io/blocky/installation/) chapter in the documentation.\n\n    ## Full documentation\n\n    You can find full documentation and configuration examples\n    at: [https://0xERR0R.github.io/blocky/](https://0xERR0R.github.io/blocky/)\n  contact:\n    name: blocky@github\n    url: https://github.com/0xERR0R/blocky\n  license:\n    name: Apache 2.0\n    url: http://www.apache.org/licenses/LICENSE-2.0.html\n  version: '1.0'\nservers:\n  - url: /api\npaths:\n  /blocking/disable:\n    get:\n      operationId: disableBlocking\n      tags:\n        - blocking\n      summary: Disable blocking\n      description: disable the blocking status\n      parameters:\n        - name: duration\n          in: query\n          description: 'duration of blocking (Example: 300s, 5m, 1h, 5m30s)'\n          schema:\n            type: string\n        - name: groups\n          in: query\n          description: groups to disable (comma separated). If empty, disable all groups\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Blocking is disabled\n        '400':\n          description: Bad request (e.g. unknown group)\n          content:\n            text/plain:\n              schema:\n                type: string\n                example: Bad request\n  /blocking/enable:\n    get:\n      operationId: enableBlocking\n      tags:\n        - blocking\n      summary: Enable blocking\n      description: enable the blocking status\n      responses:\n        '200':\n          description: Blocking is enabled\n  /blocking/status:\n    get:\n      operationId: blockingStatus\n      tags:\n        - blocking\n      summary: Blocking status\n      description: get current blocking status\n      responses:\n        '200':\n          description: Returns current blocking status\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/api.BlockingStatus'\n  /lists/refresh:\n    post:\n      operationId: listRefresh\n      tags:\n        - lists\n      summary: List refresh\n      description: Refresh all lists\n      responses:\n        '200':\n          description: Lists were reloaded\n        '500':\n          description: List refresh error\n          content:\n            text/plain:\n              schema:\n                type: string\n                example: Error text\n  /query:\n    post:\n      operationId: query\n      tags:\n        - query\n      summary: Performs DNS query\n      description: Performs DNS query\n      requestBody:\n        description: query data\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/api.QueryRequest'\n        required: true\n      responses:\n        '200':\n          description: query was executed\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/api.QueryResult'\n        '400':\n          description: Wrong request format\n          content:\n            text/plain:\n              schema:\n                type: string\n                example: Bad request\n  /cache/flush:\n    post:\n      operationId: cacheFlush\n      tags:\n        - cache\n      summary: Clears the DNS response cache\n      description: Removes all DNS responses from cache\n      responses:\n        '200':\n          description: All caches cleared\ncomponents:\n  schemas:\n    api.BlockingStatus:\n      type: object\n      properties:\n        autoEnableInSec:\n          type: integer\n          minimum: 0\n          description: &gt;-\n            If blocking is temporary disabled: amount of seconds until blocking\n            will be enabled\n        disabledGroups:\n          type: array\n          description: Disabled group names\n          items:\n            type: string\n        enabled:\n          type: boolean\n          description: True if blocking is enabled\n      required:\n        - enabled\n    api.QueryRequest:\n      type: object\n      properties:\n        query:\n          type: string\n          description: query for DNS request\n        type:\n          type: string\n          description: request type (A, AAAA, ...)\n      required:\n        - query\n        - type\n    api.QueryResult:\n      type: object\n      properties:\n        reason:\n          type: string\n          description: blocky reason for resolution\n        response:\n          type: string\n          description: actual DNS response\n        responseType:\n          type: string\n          description: response type (CACHED, BLOCKED, ...)\n        returnCode:\n          type: string\n          description: DNS return code (NOERROR, NXDOMAIN, ...)\n      required:\n        - reason\n        - response\n        - responseType\n        - returnCode\n</code></pre> <p>If http listener is enabled, blocky provides REST API. You can download the OpenAPI YAML interface specification. </p> <p>You can also browse the interactive API documentation (RapiDoc) documentation online.</p>"},{"location":"interfaces/#cli","title":"CLI","text":"<p>Blocky provides a CLI interface to control. This interface uses internally the REST API.</p> <p>To run the CLI, please ensure, that blocky DNS server is running, then execute <code>blocky help</code> for help or</p> <ul> <li><code>./blocky blocking enable</code> to enable blocking</li> <li><code>./blocky blocking disable</code> to disable blocking</li> <li><code>./blocky blocking disable --duration [duration]</code> to disable blocking for a certain amount of time (30s, 5m, 10m30s,   ...)</li> <li><code>./blocky blocking disable --groups ads,othergroup</code> to disable blocking only for special groups</li> <li><code>./blocky blocking status</code> to print current status of blocking</li> <li><code>./blocky query &lt;domain&gt;</code> execute DNS query (A) (simple replacement for dig, useful for debug purposes)</li> <li><code>./blocky query &lt;domain&gt; --type &lt;queryType&gt;</code> execute DNS query with passed query type (A, AAAA, MX, ...)</li> <li><code>./blocky lists refresh</code> reloads all allow/denylists</li> <li><code>./blocky validate [--config /path/to/config.yaml]</code> validates configuration file</li> </ul> <p>Tip</p> <p>To run this inside docker run <code>docker exec blocky ./blocky blocking status</code></p>"},{"location":"network_configuration/","title":"Network configuration","text":"<p>In order, to benefit from all the advantages of blocky like ad-blocking, privacy and speed, it is necessary to use blocky as DNS server for your devices. You can configure DNS server on each device manually or use DHCP in your network router and push the right settings to your device. With this approach, you will configure blocky only once in your router and each device in your network will automatically use blocky as DNS server.</p>"},{"location":"network_configuration/#transparent-configuration-with-dhcp","title":"Transparent configuration with DHCP","text":"<p>Let us assume, blocky is installed on a Raspberry PI with fix IP address <code>192.168.178.2</code>. Each device which connects to the router will obtain an IP address and receive the network configuration. The IP address of the Raspberry PI should be pushed to the device as DNS server.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              \u2502         \u2502 Raspberry PI    \u2502\n\u2502  Router      \u2502         \u2502   blocky        \u2502        \n\u2502              \u2502         \u2502 192.168.178.2   \u2502            \n\u2514\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \n  \u25021    \u2502                     \u2502  3                  \n  \u2502     \u2502                     \u2502                         \n  \u2502     \u2502                     \u2502 \n  \u2502     \u2502                     \u2502                     \n  \u2502     \u2502                     \u2502\n  \u2502     \u2502                     \u2502\n  \u2502     \u2502                     \u2502\n  \u2502     \u2502       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502     \u2502   2   \u2502                    \u2502\n  \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba  Network device    \u2502\n  \u2502             \u2502    Android         \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                    \u2502\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>1 - Network device asks the DHCP server (on Router) for the network configuration</p> <p>2 - Router assigns a free IP address to the device and says \"Use 192.168.178.2\" as DNS server</p> <p>3 - Clients makes DNS queries and is happy to use blocky </p> <p>Warning</p> <p>It is necessary to assign the server which runs blocky (e.g. Raspberry PI) a fix IP address.</p>"},{"location":"network_configuration/#example-configuration-with-fritzbox","title":"Example configuration with FritzBox","text":"<p>To configure the DNS server in the FritzBox, please open in the FritzBox web interface:</p> <ul> <li>in navigation menu on the left side: Home Network -&gt; Network</li> <li>Network Settings tab on the top</li> <li>\"IPv4 Configuration\" Button at the bottom op the page</li> <li>Enter the IP address of blocky under \"Local DNS server\", see screenshot</li> </ul> <p></p>"},{"location":"prometheus_grafana/","title":"Integration in Grafana","text":""},{"location":"prometheus_grafana/#prometheus","title":"Prometheus","text":""},{"location":"prometheus_grafana/#prometheus-export","title":"Prometheus export","text":"<p>Blocky can optionally export metrics for Prometheus.</p> <p>Following metrics will be exported:</p> name Description blocky_build_info Version number and build info blocky_denylist_cache_entries Gauge of entries in the denylist cache, partitioned by group blocky_allowlist_cache_entries Gauge of entries in the allowlist cache, partitioned by group blocky_error_total Counter of total queries that ended in error for any reason blocky_query_total Counter of total queries, partitioned by client and DNS request type (A, AAAA, PTR, etc) blocky_request_duration_seconds Histogram of request duration, partitioned by response type (Blocked, cached, etc) blocky_response_total Counter of responses, partitioned by response type (Blocked, cached, etc), DNS response code, and reason blocky_blocking_enabled Boolean 1 if blocking is enabled, 0 otherwise blocky_cache_entries Gauge of entries in cache blocky_cache_hits_total Counter of the number of cache hits blocky_cache_misses_total Counter of the number of Cache misses blocky_last_list_group_refresh_timestamp_seconds Timestamp of last list refresh blocky_prefetches_total Counter of prefetched DNS responses blocky_prefetch_hits_total Counter of requests that hit the prefetch cache blocky_prefetch_domain_name_cache_entries Gauge of domain names being prefetched blocky_failed_downloads_total Counter of failed list downloads blocky_dnssec_validation_total Counter of DNSSEC validations, partitioned by result (secure, insecure, bogus, indeterminate) blocky_dnssec_cache_hits_total Counter of DNSSEC validation cache hits blocky_dnssec_validation_duration_seconds Histogram of DNSSEC validation duration, partitioned by result"},{"location":"prometheus_grafana/#grafana-dashboard","title":"Grafana dashboard","text":"<p>Example Grafana dashboard definition as JSON or at grafana.com .</p> <p>This dashboard shows all relevant statistics and allows enabling and disabling the blocking status.</p>"},{"location":"prometheus_grafana/#grafana-configuration","title":"Grafana configuration","text":"<p>Please install <code>grafana-piechart-panel</code> and set disable_sanitize_html in config or as env to use control buttons to enable/disable the blocking status.</p>"},{"location":"prometheus_grafana/#grafana-and-prometheus-example-project","title":"Grafana and Prometheus example project","text":"<p>This repo contains example docker-compose.yml with blocky, prometheus (with configured scraper for blocky) and grafana with prometheus datasource.</p>"},{"location":"prometheus_grafana/#mysql-mariadb","title":"MySQL / MariaDB","text":"<p>If database query logging is activated (see Query logging), you can use following Grafana Dashboard as JSON or at grafana.com</p> <p>.</p> <p>Please define the MySQL source in Grafana, which points to the database with blocky's log entries.</p>"},{"location":"prometheus_grafana/#postgres","title":"Postgres","text":"<p>The JSON for a Grafana dashboard equivalent to the MySQL/MariaDB version is located here</p>"}]}